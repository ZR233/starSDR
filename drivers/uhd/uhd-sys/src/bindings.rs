/* automatically generated by rust-bindgen 0.68.1 */

pub const _VCRT_COMPILER_PREPROCESSOR: u32 = 1;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _STL_LANG: u32 = 0;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_CXX23: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _CRT_HAS_C11: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const _MAX_ITOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ITOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ITOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_LTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_LTOSTR_BASE10_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_LTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_ULTOSTR_BASE16_COUNT: u32 = 9;
pub const _MAX_ULTOSTR_BASE10_COUNT: u32 = 11;
pub const _MAX_ULTOSTR_BASE8_COUNT: u32 = 12;
pub const _MAX_ULTOSTR_BASE2_COUNT: u32 = 33;
pub const _MAX_I64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_I64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_I64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_I64TOSTR_BASE2_COUNT: u32 = 65;
pub const _MAX_U64TOSTR_BASE16_COUNT: u32 = 17;
pub const _MAX_U64TOSTR_BASE10_COUNT: u32 = 21;
pub const _MAX_U64TOSTR_BASE8_COUNT: u32 = 23;
pub const _MAX_U64TOSTR_BASE2_COUNT: u32 = 65;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MIN: i32 = -128;
pub const SCHAR_MAX: u32 = 127;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MIN: i32 = -128;
pub const CHAR_MAX: u32 = 127;
pub const MB_LEN_MAX: u32 = 5;
pub const SHRT_MIN: i32 = -32768;
pub const SHRT_MAX: u32 = 32767;
pub const USHRT_MAX: u32 = 65535;
pub const INT_MIN: i32 = -2147483648;
pub const INT_MAX: u32 = 2147483647;
pub const UINT_MAX: u32 = 4294967295;
pub const LONG_MIN: i32 = -2147483648;
pub const LONG_MAX: u32 = 2147483647;
pub const ULONG_MAX: u32 = 4294967295;
pub const EXIT_SUCCESS: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;
pub const _WRITE_ABORT_MSG: u32 = 1;
pub const _CALL_REPORTFAULT: u32 = 2;
pub const _OUT_TO_DEFAULT: u32 = 0;
pub const _OUT_TO_STDERR: u32 = 1;
pub const _OUT_TO_MSGBOX: u32 = 2;
pub const _REPORT_ERRMODE: u32 = 3;
pub const RAND_MAX: u32 = 32767;
pub const _CVTBUFSIZE: u32 = 349;
pub const _MAX_PATH: u32 = 260;
pub const _MAX_DRIVE: u32 = 3;
pub const _MAX_DIR: u32 = 256;
pub const _MAX_FNAME: u32 = 256;
pub const _MAX_EXT: u32 = 256;
pub const _MAX_ENV: u32 = 32767;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const _CRT_USE_CONFORMING_ANNEX_K_TIME: u32 = 0;
pub const TIME_UTC: u32 = 1;
pub const UHD_VERSION_ABI_STRING: &[u8; 6] = b"4.5.0\0";
pub const UHD_VERSION: u32 = 4050000;
pub type POINTER_64_INT = ::std::os::raw::c_ulonglong;
pub type INT8 = ::std::os::raw::c_schar;
pub type PINT8 = *mut ::std::os::raw::c_schar;
pub type INT16 = ::std::os::raw::c_short;
pub type PINT16 = *mut ::std::os::raw::c_short;
pub type INT32 = ::std::os::raw::c_int;
pub type PINT32 = *mut ::std::os::raw::c_int;
pub type INT64 = ::std::os::raw::c_longlong;
pub type PINT64 = *mut ::std::os::raw::c_longlong;
pub type UINT8 = ::std::os::raw::c_uchar;
pub type PUINT8 = *mut ::std::os::raw::c_uchar;
pub type UINT16 = ::std::os::raw::c_ushort;
pub type PUINT16 = *mut ::std::os::raw::c_ushort;
pub type UINT32 = ::std::os::raw::c_uint;
pub type PUINT32 = *mut ::std::os::raw::c_uint;
pub type UINT64 = ::std::os::raw::c_ulonglong;
pub type PUINT64 = *mut ::std::os::raw::c_ulonglong;
pub type LONG32 = ::std::os::raw::c_int;
pub type PLONG32 = *mut ::std::os::raw::c_int;
pub type ULONG32 = ::std::os::raw::c_uint;
pub type PULONG32 = *mut ::std::os::raw::c_uint;
pub type DWORD32 = ::std::os::raw::c_uint;
pub type PDWORD32 = *mut ::std::os::raw::c_uint;
pub type INT_PTR = ::std::os::raw::c_longlong;
pub type PINT_PTR = *mut ::std::os::raw::c_longlong;
pub type UINT_PTR = ::std::os::raw::c_ulonglong;
pub type PUINT_PTR = *mut ::std::os::raw::c_ulonglong;
pub type LONG_PTR = ::std::os::raw::c_longlong;
pub type PLONG_PTR = *mut ::std::os::raw::c_longlong;
pub type ULONG_PTR = ::std::os::raw::c_ulonglong;
pub type PULONG_PTR = *mut ::std::os::raw::c_ulonglong;
pub type PHANDLE64 = *mut *mut ::std::os::raw::c_void;
pub type SHANDLE_PTR = ::std::os::raw::c_longlong;
pub type HANDLE_PTR = ::std::os::raw::c_ulonglong;
pub type UHALF_PTR = ::std::os::raw::c_uint;
pub type PUHALF_PTR = *mut ::std::os::raw::c_uint;
pub type HALF_PTR = ::std::os::raw::c_int;
pub type PHALF_PTR = *mut ::std::os::raw::c_int;
pub type SIZE_T = ULONG_PTR;
pub type PSIZE_T = *mut ULONG_PTR;
pub type SSIZE_T = LONG_PTR;
pub type PSSIZE_T = *mut LONG_PTR;
pub type DWORD_PTR = ULONG_PTR;
pub type PDWORD_PTR = *mut ULONG_PTR;
pub type LONG64 = ::std::os::raw::c_longlong;
pub type PLONG64 = *mut ::std::os::raw::c_longlong;
pub type ULONG64 = ::std::os::raw::c_ulonglong;
pub type PULONG64 = *mut ::std::os::raw::c_ulonglong;
pub type DWORD64 = ::std::os::raw::c_ulonglong;
pub type PDWORD64 = *mut ::std::os::raw::c_ulonglong;
pub type KAFFINITY = ULONG_PTR;
pub type PKAFFINITY = *mut KAFFINITY;
pub type va_list = *mut ::std::os::raw::c_char;
extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}
pub type __vcrt_bool = bool;
pub type wchar_t = ::std::os::raw::c_ushort;
extern "C" {
    pub fn __security_init_cookie();
}
extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}
extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize) -> !;
}
extern "C" {
    pub static mut __security_cookie: usize;
}
pub type __crt_bool = bool;
extern "C" {
    pub fn _invalid_parameter_noinfo();
}
extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn() -> !;
}
extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    ) -> !;
}
pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___crt_locale_data_public() {
    const UNINIT: ::std::mem::MaybeUninit<__crt_locale_data_public> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_data_public>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_data_public>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_data_public))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_pctype) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_pctype)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_mb_cur_max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_mb_cur_max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._locale_lc_codepage) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_data_public),
            "::",
            stringify!(_locale_lc_codepage)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}
#[test]
fn bindgen_test_layout___crt_locale_pointers() {
    const UNINIT: ::std::mem::MaybeUninit<__crt_locale_pointers> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__crt_locale_pointers>(),
        16usize,
        concat!("Size of: ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        ::std::mem::align_of::<__crt_locale_pointers>(),
        8usize,
        concat!("Alignment of ", stringify!(__crt_locale_pointers))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).locinfo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(locinfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mbcinfo) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__crt_locale_pointers),
            "::",
            stringify!(mbcinfo)
        )
    );
}
pub type _locale_t = *mut __crt_locale_pointers;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}
#[test]
fn bindgen_test_layout__Mbstatet() {
    const UNINIT: ::std::mem::MaybeUninit<_Mbstatet> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_Mbstatet>(),
        8usize,
        concat!("Size of: ", stringify!(_Mbstatet))
    );
    assert_eq!(
        ::std::mem::align_of::<_Mbstatet>(),
        4usize,
        concat!("Alignment of ", stringify!(_Mbstatet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Wchar) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Wchar)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._Byte) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_Byte)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._State) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(_Mbstatet),
            "::",
            stringify!(_State)
        )
    );
}
pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;
extern "C" {
    pub fn _calloc_base(_Count: usize, _Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn calloc(
        _Count: ::std::os::raw::c_ulonglong,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _callnewh(_Size: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _expand(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _free_base(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _malloc_base(_Size: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn malloc(_Size: ::std::os::raw::c_ulonglong) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _msize_base(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _msize(_Block: *mut ::std::os::raw::c_void) -> usize;
}
extern "C" {
    pub fn _realloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: ::std::os::raw::c_ulonglong,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc_base(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_free(_Block: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn _aligned_malloc(_Size: usize, _Alignment: usize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_malloc(
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_msize(
        _Block: *mut ::std::os::raw::c_void,
        _Alignment: usize,
        _Offset: usize,
    ) -> usize;
}
extern "C" {
    pub fn _aligned_offset_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_offset_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
        _Offset: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_realloc(
        _Block: *mut ::std::os::raw::c_void,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _aligned_recalloc(
        _Block: *mut ::std::os::raw::c_void,
        _Count: usize,
        _Size: usize,
        _Alignment: usize,
    ) -> *mut ::std::os::raw::c_void;
}
pub type max_align_t = f64;
pub type _CoreCrtSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *mut ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
        arg3: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
pub type _CoreCrtNonSecureSearchSortCompareFunction = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const ::std::os::raw::c_void,
        arg2: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn bsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort_s(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: rsize_t,
        _SizeOfElements: rsize_t,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn bsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn qsort(
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: usize,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    );
}
extern "C" {
    pub fn _lfind_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch_s(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: usize,
        _CompareFunction: _CoreCrtSecureSearchSortCompareFunction,
        _Context: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lfind(
        _Key: *const ::std::os::raw::c_void,
        _Base: *const ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn lsearch(
        _Key: *const ::std::os::raw::c_void,
        _Base: *mut ::std::os::raw::c_void,
        _NumOfElements: *mut ::std::os::raw::c_uint,
        _SizeOfElements: ::std::os::raw::c_uint,
        _CompareFunction: _CoreCrtNonSecureSearchSortCompareFunction,
    ) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn _itow_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itow(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ltow_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltow(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ultow_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultow(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn wcstod(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstod_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstol(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wcstol_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoll(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoll_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoul(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _wcstoul_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcstoull(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoull_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn wcstold(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f64;
}
extern "C" {
    pub fn _wcstold_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn wcstof(_String: *const wchar_t, _EndPtr: *mut *mut wchar_t) -> f32;
}
extern "C" {
    pub fn _wcstof_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn _wtof(_String: *const wchar_t) -> f64;
}
extern "C" {
    pub fn _wtof_l(_String: *const wchar_t, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _wtoi(_String: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtoi_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wtol(_String: *const wchar_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtol_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _wtoll(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoll_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _i64tow_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64tow(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _ui64tow_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64tow(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wtoi64(_String: *const wchar_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wtoi64_l(_String: *const wchar_t, _Locale: _locale_t) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoi64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _wcstoui64(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wcstoui64_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _wfullpath(
        _Buffer: *mut wchar_t,
        _Path: *const wchar_t,
        _BufferCount: usize,
    ) -> *mut wchar_t;
}
extern "C" {
    pub fn _wmakepath_s(
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wmakepath(
        _Buffer: *mut wchar_t,
        _Drive: *const wchar_t,
        _Dir: *const wchar_t,
        _Filename: *const wchar_t,
        _Ext: *const wchar_t,
    );
}
extern "C" {
    pub fn _wperror(_ErrorMessage: *const wchar_t);
}
extern "C" {
    pub fn _wsplitpath(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _Dir: *mut wchar_t,
        _Filename: *mut wchar_t,
        _Ext: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsplitpath_s(
        _FullPath: *const wchar_t,
        _Drive: *mut wchar_t,
        _DriveCount: usize,
        _Dir: *mut wchar_t,
        _DirCount: usize,
        _Filename: *mut wchar_t,
        _FilenameCount: usize,
        _Ext: *mut wchar_t,
        _ExtCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wdupenv_s(
        _Buffer: *mut *mut wchar_t,
        _BufferCount: *mut usize,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wgetenv(_VarName: *const wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wgetenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
        _VarName: *const wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wputenv(_EnvString: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wputenv_s(_Name: *const wchar_t, _Value: *const wchar_t) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv_s(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _Buffer: *mut wchar_t,
        _BufferCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _wsearchenv(
        _Filename: *const wchar_t,
        _VarName: *const wchar_t,
        _ResultPath: *mut wchar_t,
    );
}
extern "C" {
    pub fn _wsystem(_Command: *const wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn _Exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn quick_exit(_Code: ::std::os::raw::c_int) -> !;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn _set_abort_behavior(
        _Flags: ::std::os::raw::c_uint,
        _Mask: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
pub type _onexit_t = ::std::option::Option<unsafe extern "C" fn() -> ::std::os::raw::c_int>;
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _onexit(_Func: _onexit_t) -> _onexit_t;
}
extern "C" {
    pub fn at_quick_exit(
        arg1: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub type _purecall_handler = ::std::option::Option<unsafe extern "C" fn()>;
pub type _invalid_parameter_handler = ::std::option::Option<
    unsafe extern "C" fn(
        arg1: *const wchar_t,
        arg2: *const wchar_t,
        arg3: *const wchar_t,
        arg4: ::std::os::raw::c_uint,
        arg5: usize,
    ),
>;
extern "C" {
    pub fn _set_purecall_handler(_Handler: _purecall_handler) -> _purecall_handler;
}
extern "C" {
    pub fn _get_purecall_handler() -> _purecall_handler;
}
extern "C" {
    pub fn _set_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_thread_local_invalid_parameter_handler(
        _Handler: _invalid_parameter_handler,
    ) -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _get_thread_local_invalid_parameter_handler() -> _invalid_parameter_handler;
}
extern "C" {
    pub fn _set_error_mode(_Mode: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _errno() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _set_errno(_Value: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_errno(_Value: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn __doserrno() -> *mut ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _set_doserrno(_Value: ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn _get_doserrno(_Value: *mut ::std::os::raw::c_ulong) -> errno_t;
}
extern "C" {
    pub fn __sys_errlist() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __sys_nerr() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(_ErrMsg: *const ::std::os::raw::c_char);
}
extern "C" {
    pub fn __p__pgmptr() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wpgmptr() -> *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__fmode() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn _get_pgmptr(_Value: *mut *mut ::std::os::raw::c_char) -> errno_t;
}
extern "C" {
    pub fn _get_wpgmptr(_Value: *mut *mut wchar_t) -> errno_t;
}
extern "C" {
    pub fn _set_fmode(_Mode: ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_fmode(_PMode: *mut ::std::os::raw::c_int) -> errno_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _div_t {
    pub quot: ::std::os::raw::c_int,
    pub rem: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__div_t() {
    const UNINIT: ::std::mem::MaybeUninit<_div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_div_t>(),
        8usize,
        concat!("Size of: ", stringify!(_div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_div_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type div_t = _div_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _ldiv_t {
    pub quot: ::std::os::raw::c_long,
    pub rem: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<_ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_ldiv_t>(),
        8usize,
        concat!("Size of: ", stringify!(_ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_ldiv_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type ldiv_t = _ldiv_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _lldiv_t {
    pub quot: ::std::os::raw::c_longlong,
    pub rem: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout__lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<_lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(_lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
pub type lldiv_t = _lldiv_t;
extern "C" {
    pub fn abs(_Number: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn labs(_Number: ::std::os::raw::c_long) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn llabs(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _abs64(_Number: ::std::os::raw::c_longlong) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _byteswap_ushort(_Number: ::std::os::raw::c_ushort) -> ::std::os::raw::c_ushort;
}
extern "C" {
    pub fn _byteswap_ulong(_Number: ::std::os::raw::c_ulong) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _byteswap_uint64(_Number: ::std::os::raw::c_ulonglong) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn div(_Numerator: ::std::os::raw::c_int, _Denominator: ::std::os::raw::c_int) -> div_t;
}
extern "C" {
    pub fn ldiv(_Numerator: ::std::os::raw::c_long, _Denominator: ::std::os::raw::c_long)
        -> ldiv_t;
}
extern "C" {
    pub fn lldiv(
        _Numerator: ::std::os::raw::c_longlong,
        _Denominator: ::std::os::raw::c_longlong,
    ) -> lldiv_t;
}
extern "C" {
    pub fn _rotl(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotl(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotl64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _rotr(
        _Value: ::std::os::raw::c_uint,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _lrotr(
        _Value: ::std::os::raw::c_ulong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _rotr64(
        _Value: ::std::os::raw::c_ulonglong,
        _Shift: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn srand(_Seed: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn rand() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDOUBLE {
    pub ld: [::std::os::raw::c_uchar; 10usize],
}
#[test]
fn bindgen_test_layout__LDOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_LDOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDOUBLE>(),
        10usize,
        concat!("Size of: ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDOUBLE>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ld) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDOUBLE),
            "::",
            stringify!(ld)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_DOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__CRT_DOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_CRT_DOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_DOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_CRT_DOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CRT_DOUBLE),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _CRT_FLOAT {
    pub f: f32,
}
#[test]
fn bindgen_test_layout__CRT_FLOAT() {
    const UNINIT: ::std::mem::MaybeUninit<_CRT_FLOAT> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Size of: ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        ::std::mem::align_of::<_CRT_FLOAT>(),
        4usize,
        concat!("Alignment of ", stringify!(_CRT_FLOAT))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).f) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_CRT_FLOAT),
            "::",
            stringify!(f)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LONGDOUBLE {
    pub x: f64,
}
#[test]
fn bindgen_test_layout__LONGDOUBLE() {
    const UNINIT: ::std::mem::MaybeUninit<_LONGDOUBLE> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Size of: ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        ::std::mem::align_of::<_LONGDOUBLE>(),
        8usize,
        concat!("Alignment of ", stringify!(_LONGDOUBLE))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LONGDOUBLE),
            "::",
            stringify!(x)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _LDBL12 {
    pub ld12: [::std::os::raw::c_uchar; 12usize],
}
#[test]
fn bindgen_test_layout__LDBL12() {
    const UNINIT: ::std::mem::MaybeUninit<_LDBL12> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_LDBL12>(),
        12usize,
        concat!("Size of: ", stringify!(_LDBL12))
    );
    assert_eq!(
        ::std::mem::align_of::<_LDBL12>(),
        1usize,
        concat!("Alignment of ", stringify!(_LDBL12))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ld12) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_LDBL12),
            "::",
            stringify!(ld12)
        )
    );
}
extern "C" {
    pub fn atof(_String: *const ::std::os::raw::c_char) -> f64;
}
extern "C" {
    pub fn atoi(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn atol(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn atoll(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64(_String: *const ::std::os::raw::c_char) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atof_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> f64;
}
extern "C" {
    pub fn _atoi_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atol_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _atoll_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoi64_l(
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _atoflt(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoflt_l(
        _Result: *mut _CRT_FLOAT,
        _String: *const ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atodbl_l(
        _Result: *mut _CRT_DOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _atoldbl_l(
        _Result: *mut _LDOUBLE,
        _String: *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn strtof(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f32;
}
extern "C" {
    pub fn _strtof_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f32;
}
extern "C" {
    pub fn strtod(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtod_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtold(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
    ) -> f64;
}
extern "C" {
    pub fn _strtold_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Locale: _locale_t,
    ) -> f64;
}
extern "C" {
    pub fn strtol(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn _strtol_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn strtoll(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoll_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn strtoul(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn _strtoul_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn strtoull(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoull_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoi64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoi64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn _strtoui64(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _strtoui64_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn _itoa_s(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ltoa_s(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ultoa_s(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _i64toa_s(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _i64toa(
        _Value: ::std::os::raw::c_longlong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ui64toa_s(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Radix: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ui64toa(
        _Value: ::std::os::raw::c_ulonglong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ecvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _fcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _gcvt_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn _gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ___mb_cur_max_func() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ___mb_cur_max_l_func(_Locale: _locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mblen(_Ch: *const ::std::os::raw::c_char, _MaxCount: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mblen_l(
        _Ch: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbstrlen(_String: *const ::std::os::raw::c_char) -> usize;
}
extern "C" {
    pub fn _mbstrlen_l(_String: *const ::std::os::raw::c_char, _Locale: _locale_t) -> usize;
}
extern "C" {
    pub fn _mbstrnlen(_String: *const ::std::os::raw::c_char, _MaxCount: usize) -> usize;
}
extern "C" {
    pub fn _mbstrnlen_l(
        _String: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn mbtowc(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _mbtowc_l(
        _DstCh: *mut wchar_t,
        _SrcCh: *const ::std::os::raw::c_char,
        _SrcSizeInBytes: usize,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbstowcs_s(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn mbstowcs(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _mbstowcs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _DstBuf: *mut wchar_t,
        _SizeInWords: usize,
        _SrcBuf: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _mbstowcs_l(
        _Dest: *mut wchar_t,
        _Source: *const ::std::os::raw::c_char,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn wctomb(_MbCh: *mut ::std::os::raw::c_char, _WCh: wchar_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _wctomb_l(
        _MbCh: *mut ::std::os::raw::c_char,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wctomb_s(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: rsize_t,
        _WCh: wchar_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wctomb_s_l(
        _SizeConverted: *mut ::std::os::raw::c_int,
        _MbCh: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _WCh: wchar_t,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs_s(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn wcstombs(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: usize,
    ) -> usize;
}
extern "C" {
    pub fn _wcstombs_s_l(
        _PtNumOfCharConverted: *mut usize,
        _Dst: *mut ::std::os::raw::c_char,
        _DstSizeInBytes: usize,
        _Src: *const wchar_t,
        _MaxCountInBytes: usize,
        _Locale: _locale_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wcstombs_l(
        _Dest: *mut ::std::os::raw::c_char,
        _Source: *const wchar_t,
        _MaxCount: usize,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn _fullpath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Path: *const ::std::os::raw::c_char,
        _BufferCount: usize,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _makepath_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _makepath(
        _Buffer: *mut ::std::os::raw::c_char,
        _Drive: *const ::std::os::raw::c_char,
        _Dir: *const ::std::os::raw::c_char,
        _Filename: *const ::std::os::raw::c_char,
        _Ext: *const ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _Dir: *mut ::std::os::raw::c_char,
        _Filename: *mut ::std::os::raw::c_char,
        _Ext: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _splitpath_s(
        _FullPath: *const ::std::os::raw::c_char,
        _Drive: *mut ::std::os::raw::c_char,
        _DriveCount: usize,
        _Dir: *mut ::std::os::raw::c_char,
        _DirCount: usize,
        _Filename: *mut ::std::os::raw::c_char,
        _FilenameCount: usize,
        _Ext: *mut ::std::os::raw::c_char,
        _ExtCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn getenv_s(
        _RequiredCount: *mut usize,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: rsize_t,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn __p___argc() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __p___argv() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p___wargv() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn __p__environ() -> *mut *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __p__wenviron() -> *mut *mut *mut wchar_t;
}
extern "C" {
    pub fn getenv(_VarName: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _dupenv_s(
        _Buffer: *mut *mut ::std::os::raw::c_char,
        _BufferCount: *mut usize,
        _VarName: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn system(_Command: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _putenv_s(
        _Name: *const ::std::os::raw::c_char,
        _Value: *const ::std::os::raw::c_char,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv_s(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
        _BufferCount: usize,
    ) -> errno_t;
}
extern "C" {
    pub fn _searchenv(
        _Filename: *const ::std::os::raw::c_char,
        _VarName: *const ::std::os::raw::c_char,
        _Buffer: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn _seterrormode(_Mode: ::std::os::raw::c_int);
}
extern "C" {
    pub fn _beep(_Frequency: ::std::os::raw::c_uint, _Duration: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn _sleep(_Duration: ::std::os::raw::c_ulong);
}
extern "C" {
    pub fn ecvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fcvt(
        _Value: f64,
        _FractionalDigitCount: ::std::os::raw::c_int,
        _PtDec: *mut ::std::os::raw::c_int,
        _PtSign: *mut ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn gcvt(
        _Value: f64,
        _DigitCount: ::std::os::raw::c_int,
        _DstBuf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn itoa(
        _Value: ::std::os::raw::c_int,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ltoa(
        _Value: ::std::os::raw::c_long,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn swab(
        _Buf1: *mut ::std::os::raw::c_char,
        _Buf2: *mut ::std::os::raw::c_char,
        _SizeInBytes: ::std::os::raw::c_int,
    );
}
extern "C" {
    pub fn ultoa(
        _Value: ::std::os::raw::c_ulong,
        _Buffer: *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn putenv(_EnvString: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn onexit(_Func: _onexit_t) -> _onexit_t;
}
#[doc = "! No error thrown."]
pub const uhd_error_UHD_ERROR_NONE: uhd_error = 0;
#[doc = "! Invalid device arguments."]
pub const uhd_error_UHD_ERROR_INVALID_DEVICE: uhd_error = 1;
#[doc = "! See uhd::index_error."]
pub const uhd_error_UHD_ERROR_INDEX: uhd_error = 10;
#[doc = "! See uhd::key_error."]
pub const uhd_error_UHD_ERROR_KEY: uhd_error = 11;
#[doc = "! See uhd::not_implemented_error."]
pub const uhd_error_UHD_ERROR_NOT_IMPLEMENTED: uhd_error = 20;
#[doc = "! See uhd::usb_error."]
pub const uhd_error_UHD_ERROR_USB: uhd_error = 21;
#[doc = "! See uhd::io_error."]
pub const uhd_error_UHD_ERROR_IO: uhd_error = 30;
#[doc = "! See uhd::os_error."]
pub const uhd_error_UHD_ERROR_OS: uhd_error = 31;
#[doc = "! See uhd::assertion_error."]
pub const uhd_error_UHD_ERROR_ASSERTION: uhd_error = 40;
#[doc = "! See uhd::lookup_error."]
pub const uhd_error_UHD_ERROR_LOOKUP: uhd_error = 41;
#[doc = "! See uhd::type_error."]
pub const uhd_error_UHD_ERROR_TYPE: uhd_error = 42;
#[doc = "! See uhd::value_error."]
pub const uhd_error_UHD_ERROR_VALUE: uhd_error = 43;
#[doc = "! See uhd::runtime_error."]
pub const uhd_error_UHD_ERROR_RUNTIME: uhd_error = 44;
#[doc = "! See uhd::environment_error."]
pub const uhd_error_UHD_ERROR_ENVIRONMENT: uhd_error = 45;
#[doc = "! See uhd::system_error."]
pub const uhd_error_UHD_ERROR_SYSTEM: uhd_error = 46;
#[doc = "! See uhd::exception."]
pub const uhd_error_UHD_ERROR_EXCEPT: uhd_error = 47;
#[doc = "! A boost::exception was thrown."]
pub const uhd_error_UHD_ERROR_BOOSTEXCEPT: uhd_error = 60;
#[doc = "! A std::exception was thrown."]
pub const uhd_error_UHD_ERROR_STDEXCEPT: uhd_error = 70;
#[doc = "! An unknown error was thrown."]
pub const uhd_error_UHD_ERROR_UNKNOWN: uhd_error = 100;
#[doc = "! UHD error codes\n*!\n* Each error code corresponds to a specific uhd::exception, with\n* extra codes corresponding to a boost::exception, std::exception,\n* and a catch-all for everything else. When an internal C++ function\n* throws an exception, UHD converts it to one of these error codes\n* to return on the C level.\n*/"]
pub type uhd_error = ::std::os::raw::c_int;
extern "C" {
    #[doc = "! Return the last error string reported by UHD\n*!\n* Functions that do not take in UHD structs/handles will place any error\n* strings into a buffer that can be queried with this function. Functions that\n* do take in UHD structs/handles will place their error strings in both locations.\n*/"]
    pub fn uhd_get_last_error(
        error_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the ABI compatibility string for this build of the library"]
    pub fn uhd_get_abi_string(
        abi_string_out: *mut ::std::os::raw::c_char,
        buffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the version string (dotted version number + build info)"]
    pub fn uhd_get_version_string(
        version_out: *mut ::std::os::raw::c_char,
        buffer_len: usize,
    ) -> uhd_error;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_tm() {
    const UNINIT: ::std::mem::MaybeUninit<tm> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        36usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        4usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_min) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_hour) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mday) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_mon) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_year) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_wday) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_yday) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tm_isdst) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
}
extern "C" {
    pub fn _wasctime(_Tm: *const tm) -> *mut wchar_t;
}
extern "C" {
    pub fn _wasctime_s(_Buffer: *mut wchar_t, _SizeInWords: usize, _Tm: *const tm) -> errno_t;
}
extern "C" {
    pub fn wcsftime(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _Format: *const wchar_t,
        _Tm: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn _wcsftime_l(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _Format: *const wchar_t,
        _Tm: *const tm,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn _wctime32(_Time: *const __time32_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wctime32_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _Time: *const __time32_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wctime64(_Time: *const __time64_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wctime64_s(
        _Buffer: *mut wchar_t,
        _SizeInWords: usize,
        _Time: *const __time64_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _wstrdate_s(_Buffer: *mut wchar_t, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wstrdate(_Buffer: *mut wchar_t) -> *mut wchar_t;
}
extern "C" {
    pub fn _wstrtime_s(_Buffer: *mut wchar_t, _SizeInWords: usize) -> errno_t;
}
extern "C" {
    pub fn _wstrtime(_Buffer: *mut wchar_t) -> *mut wchar_t;
}
pub type clock_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _timespec32 {
    pub tv_sec: __time32_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__timespec32() {
    const UNINIT: ::std::mem::MaybeUninit<_timespec32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_timespec32>(),
        8usize,
        concat!("Size of: ", stringify!(_timespec32))
    );
    assert_eq!(
        ::std::mem::align_of::<_timespec32>(),
        4usize,
        concat!("Alignment of ", stringify!(_timespec32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_timespec32),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_timespec32),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _timespec64 {
    pub tv_sec: __time64_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout__timespec64() {
    const UNINIT: ::std::mem::MaybeUninit<_timespec64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_timespec64>(),
        16usize,
        concat!("Size of: ", stringify!(_timespec64))
    );
    assert_eq!(
        ::std::mem::align_of::<_timespec64>(),
        8usize,
        concat!("Alignment of ", stringify!(_timespec64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_timespec64),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_timespec64),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    const UNINIT: ::std::mem::MaybeUninit<timespec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_nsec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
extern "C" {
    pub fn __daylight() -> *mut ::std::os::raw::c_int;
}
extern "C" {
    pub fn __dstbias() -> *mut ::std::os::raw::c_long;
}
extern "C" {
    pub fn __timezone() -> *mut ::std::os::raw::c_long;
}
extern "C" {
    pub fn __tzname() -> *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _get_daylight(_Daylight: *mut ::std::os::raw::c_int) -> errno_t;
}
extern "C" {
    pub fn _get_dstbias(_DaylightSavingsBias: *mut ::std::os::raw::c_long) -> errno_t;
}
extern "C" {
    pub fn _get_timezone(_TimeZone: *mut ::std::os::raw::c_long) -> errno_t;
}
extern "C" {
    pub fn _get_tzname(
        _ReturnValue: *mut usize,
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Index: ::std::os::raw::c_int,
    ) -> errno_t;
}
extern "C" {
    pub fn asctime(_Tm: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Tm: *const tm,
    ) -> errno_t;
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn _ctime32(_Time: *const __time32_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ctime32_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Time: *const __time32_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _ctime64(_Time: *const __time64_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _ctime64_s(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Time: *const __time64_t,
    ) -> errno_t;
}
extern "C" {
    pub fn _difftime32(_Time1: __time32_t, _Time2: __time32_t) -> f64;
}
extern "C" {
    pub fn _difftime64(_Time1: __time64_t, _Time2: __time64_t) -> f64;
}
extern "C" {
    pub fn _gmtime32(_Time: *const __time32_t) -> *mut tm;
}
extern "C" {
    pub fn _gmtime32_s(_Tm: *mut tm, _Time: *const __time32_t) -> errno_t;
}
extern "C" {
    pub fn _gmtime64(_Time: *const __time64_t) -> *mut tm;
}
extern "C" {
    pub fn _gmtime64_s(_Tm: *mut tm, _Time: *const __time64_t) -> errno_t;
}
extern "C" {
    pub fn _localtime32(_Time: *const __time32_t) -> *mut tm;
}
extern "C" {
    pub fn _localtime32_s(_Tm: *mut tm, _Time: *const __time32_t) -> errno_t;
}
extern "C" {
    pub fn _localtime64(_Time: *const __time64_t) -> *mut tm;
}
extern "C" {
    pub fn _localtime64_s(_Tm: *mut tm, _Time: *const __time64_t) -> errno_t;
}
extern "C" {
    pub fn _mkgmtime32(_Tm: *mut tm) -> __time32_t;
}
extern "C" {
    pub fn _mkgmtime64(_Tm: *mut tm) -> __time64_t;
}
extern "C" {
    pub fn _mktime32(_Tm: *mut tm) -> __time32_t;
}
extern "C" {
    pub fn _mktime64(_Tm: *mut tm) -> __time64_t;
}
extern "C" {
    pub fn strftime(
        _Buffer: *mut ::std::os::raw::c_char,
        _SizeInBytes: usize,
        _Format: *const ::std::os::raw::c_char,
        _Tm: *const tm,
    ) -> usize;
}
extern "C" {
    pub fn _strftime_l(
        _Buffer: *mut ::std::os::raw::c_char,
        _MaxSize: usize,
        _Format: *const ::std::os::raw::c_char,
        _Tm: *const tm,
        _Locale: _locale_t,
    ) -> usize;
}
extern "C" {
    pub fn _strdate_s(_Buffer: *mut ::std::os::raw::c_char, _SizeInBytes: usize) -> errno_t;
}
extern "C" {
    pub fn _strdate(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _strtime_s(_Buffer: *mut ::std::os::raw::c_char, _SizeInBytes: usize) -> errno_t;
}
extern "C" {
    pub fn _strtime(_Buffer: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn _time32(_Time: *mut __time32_t) -> __time32_t;
}
extern "C" {
    pub fn _time64(_Time: *mut __time64_t) -> __time64_t;
}
extern "C" {
    pub fn _timespec32_get(
        _Ts: *mut _timespec32,
        _Base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _timespec64_get(
        _Ts: *mut _timespec64,
        _Base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _tzset();
}
extern "C" {
    pub fn _getsystime(_Tm: *mut tm) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn _setsystime(
        _Tm: *mut tm,
        _Milliseconds: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn tzset();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_rx_metadata_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_tx_metadata_t {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_async_metadata_t {
    _unused: [u8; 0],
}
#[doc = "! RX metadata interface for describing sent IF data.\n*!\n* See uhd::rx_metadata_t for details.\n*\n* NOTE: Using this handle before calling uhd_rx_metadata_make() will\n* result in undefined behavior.\n*/"]
pub type uhd_rx_metadata_handle = *mut uhd_rx_metadata_t;
#[doc = "! TX metadata interface for describing received IF data.\n*!\n* See uhd::tx_metadata_t for details.\n*\n* NOTE: Using this handle before calling uhd_tx_metadata_make() will\n* result in undefined behavior.\n*/"]
pub type uhd_tx_metadata_handle = *mut uhd_tx_metadata_t;
#[doc = "! Interface for describing transmit-related events.\n*!\n* See uhd::async_metadata_t for details.\n*\n* NOTE: Using this handle before calling uhd_async_metadata_make() will\n* result in undefined behavior.\n*/"]
pub type uhd_async_metadata_handle = *mut uhd_async_metadata_t;
#[doc = "! No error code associated with this metadata"]
pub const uhd_rx_metadata_error_code_t_UHD_RX_METADATA_ERROR_CODE_NONE:
    uhd_rx_metadata_error_code_t = 0;
#[doc = "! No packet received, implementation timed out"]
pub const uhd_rx_metadata_error_code_t_UHD_RX_METADATA_ERROR_CODE_TIMEOUT:
    uhd_rx_metadata_error_code_t = 1;
#[doc = "! A stream command was issued in the past"]
pub const uhd_rx_metadata_error_code_t_UHD_RX_METADATA_ERROR_CODE_LATE_COMMAND:
    uhd_rx_metadata_error_code_t = 2;
#[doc = "! Expected another stream command"]
pub const uhd_rx_metadata_error_code_t_UHD_RX_METADATA_ERROR_CODE_BROKEN_CHAIN:
    uhd_rx_metadata_error_code_t = 4;
#[doc = "! Overflow or sequence error"]
pub const uhd_rx_metadata_error_code_t_UHD_RX_METADATA_ERROR_CODE_OVERFLOW:
    uhd_rx_metadata_error_code_t = 8;
#[doc = "! Multi-channel alignment failed"]
pub const uhd_rx_metadata_error_code_t_UHD_RX_METADATA_ERROR_CODE_ALIGNMENT:
    uhd_rx_metadata_error_code_t = 12;
#[doc = "! The packet could not be parsed"]
pub const uhd_rx_metadata_error_code_t_UHD_RX_METADATA_ERROR_CODE_BAD_PACKET:
    uhd_rx_metadata_error_code_t = 15;
#[doc = "! Error condition on a receive call\n*!\n* See uhd::rx_metadata_t::error_code_t for more details.\n*/"]
pub type uhd_rx_metadata_error_code_t = ::std::os::raw::c_int;
extern "C" {
    #[doc = "! Create a new RX metadata handle"]
    pub fn uhd_rx_metadata_make(handle: *mut uhd_rx_metadata_handle) -> uhd_error;
}
extern "C" {
    #[doc = "! Free an RX metadata handle\n*!\n* Using a handle after freeing it here will result in a segmentation fault.\n*/"]
    pub fn uhd_rx_metadata_free(handle: *mut uhd_rx_metadata_handle) -> uhd_error;
}
extern "C" {
    #[doc = "! Has time specification?"]
    pub fn uhd_rx_metadata_has_time_spec(
        h: uhd_rx_metadata_handle,
        result_out: *mut bool,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Time of first sample"]
    pub fn uhd_rx_metadata_time_spec(
        h: uhd_rx_metadata_handle,
        full_secs_out: *mut i64,
        frac_secs_out: *mut f64,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Fragmentation flag"]
    pub fn uhd_rx_metadata_more_fragments(
        h: uhd_rx_metadata_handle,
        result_out: *mut bool,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Fragmentation offset"]
    pub fn uhd_rx_metadata_fragment_offset(
        h: uhd_rx_metadata_handle,
        fragment_offset_out: *mut usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Start of burst?"]
    pub fn uhd_rx_metadata_start_of_burst(
        h: uhd_rx_metadata_handle,
        result_out: *mut bool,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! End of burst?"]
    pub fn uhd_rx_metadata_end_of_burst(
        h: uhd_rx_metadata_handle,
        result_out: *mut bool,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Result out of sequence?"]
    pub fn uhd_rx_metadata_out_of_sequence(
        h: uhd_rx_metadata_handle,
        result_out: *mut bool,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Return a pretty-print representation of this metadata.\n*!\n* NOTE: This function will overwrite any string in the given buffer\n* before inserting the pp_string.\n*\n* \\param h metadata handle\n* \\param pp_string_out string buffer for pp_string\n* \\param strbuffer_len buffer length\n*/"]
    pub fn uhd_rx_metadata_to_pp_string(
        h: uhd_rx_metadata_handle,
        pp_string_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the last error state of the RX metadata object."]
    pub fn uhd_rx_metadata_error_code(
        h: uhd_rx_metadata_handle,
        error_code_out: *mut uhd_rx_metadata_error_code_t,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get a string representation of the last error state of the RX metadata object.\n*!\n* NOTES:\n* <ul>\n* <li>This is different from the error that can be retrieved with\n*     uhd_rx_metadata_last_error. See uhd::rx_metadata_t::strerror() for details.</li>\n* <li>This function will overwrite any string in the given buffer before\n*     inserting the error string.</li>\n* </ul>\n*\n* \\param h metadata handle\n* \\param strerror_out string buffer for strerror\n* \\param strbuffer_len buffer length\n*/"]
    pub fn uhd_rx_metadata_strerror(
        h: uhd_rx_metadata_handle,
        strerror_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the last error logged by the RX metadata object.\n*!\n* NOTES:\n* <ul>\n* <li>This is different from the error that can be retrieved with\n*     uhd_rx_metadata_strerror(). See <uhd/error.h> for details.</li>\n* <li>This function will overwrite any string in the given buffer before\n*     inserting the error string.</li>\n* </ul>\n*\n* \\param h metadata handle\n* \\param error_out string buffer for error\n* \\param strbuffer_len buffer length\n*/"]
    pub fn uhd_rx_metadata_last_error(
        h: uhd_rx_metadata_handle,
        error_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Create a new TX metadata handle"]
    pub fn uhd_tx_metadata_make(
        handle: *mut uhd_tx_metadata_handle,
        has_time_spec: bool,
        full_secs: i64,
        frac_secs: f64,
        start_of_burst: bool,
        end_of_burst: bool,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Free an TX metadata handle\n*!\n* Using a handle after freeing it here will result in a segmentation fault.\n*/"]
    pub fn uhd_tx_metadata_free(handle: *mut uhd_tx_metadata_handle) -> uhd_error;
}
extern "C" {
    #[doc = "! Has time specification?"]
    pub fn uhd_tx_metadata_has_time_spec(
        h: uhd_tx_metadata_handle,
        result_out: *mut bool,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get time specification"]
    pub fn uhd_tx_metadata_time_spec(
        h: uhd_tx_metadata_handle,
        full_secs_out: *mut i64,
        frac_secs_out: *mut f64,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Start of burst?"]
    pub fn uhd_tx_metadata_start_of_burst(
        h: uhd_tx_metadata_handle,
        result_out: *mut bool,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! End of burst?"]
    pub fn uhd_tx_metadata_end_of_burst(
        h: uhd_tx_metadata_handle,
        result_out: *mut bool,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the last error logged by the TX metadata object.\n*!\n* NOTE: This function will overwrite any string in the given buffer before\n* inserting the error string.\n*\n* \\param h metadata handle\n* \\param error_out string buffer for error\n* \\param strbuffer_len buffer length\n*/"]
    pub fn uhd_tx_metadata_last_error(
        h: uhd_tx_metadata_handle,
        error_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
#[doc = "! A burst was successfully transmitted."]
pub const uhd_async_metadata_event_code_t_UHD_ASYNC_METADATA_EVENT_CODE_BURST_ACK:
    uhd_async_metadata_event_code_t = 1;
#[doc = "! An internal send buffer has emptied."]
pub const uhd_async_metadata_event_code_t_UHD_ASYNC_METADATA_EVENT_CODE_UNDERFLOW:
    uhd_async_metadata_event_code_t = 2;
#[doc = "! Packet loss error between host and device."]
pub const uhd_async_metadata_event_code_t_UHD_ASYNC_METADATA_EVENT_CODE_SEQ_ERROR:
    uhd_async_metadata_event_code_t = 4;
#[doc = "! Packet had time that was late."]
pub const uhd_async_metadata_event_code_t_UHD_ASYNC_METADATA_EVENT_CODE_TIME_ERROR:
    uhd_async_metadata_event_code_t = 8;
#[doc = "! Underflow occurred inside a packet."]
pub const uhd_async_metadata_event_code_t_UHD_ASYNC_METADATA_EVENT_CODE_UNDERFLOW_IN_PACKET:
    uhd_async_metadata_event_code_t = 16;
#[doc = "! Packet loss within a burst."]
pub const uhd_async_metadata_event_code_t_UHD_ASYNC_METADATA_EVENT_CODE_SEQ_ERROR_IN_BURST:
    uhd_async_metadata_event_code_t = 32;
#[doc = "! Some kind of custom user payload."]
pub const uhd_async_metadata_event_code_t_UHD_ASYNC_METADATA_EVENT_CODE_USER_PAYLOAD:
    uhd_async_metadata_event_code_t = 64;
#[doc = "! The type of event for a receive async message call.\n*!\n* See uhd::async_metadata_t::event_code_t for more details.\n*/"]
pub type uhd_async_metadata_event_code_t = ::std::os::raw::c_int;
extern "C" {
    #[doc = "! Create a new async metadata handle"]
    pub fn uhd_async_metadata_make(handle: *mut uhd_async_metadata_handle) -> uhd_error;
}
extern "C" {
    #[doc = "! Free an async metadata handle\n*!\n* Using a handle after freeing it will result in a segmentation fault.\n*/"]
    pub fn uhd_async_metadata_free(handle: *mut uhd_async_metadata_handle) -> uhd_error;
}
extern "C" {
    #[doc = "! Channel number in a MIMO configuration"]
    pub fn uhd_async_metadata_channel(
        h: uhd_async_metadata_handle,
        channel_out: *mut usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Has time specification?"]
    pub fn uhd_async_metadata_has_time_spec(
        h: uhd_async_metadata_handle,
        result_out: *mut bool,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get time specification"]
    pub fn uhd_async_metadata_time_spec(
        h: uhd_async_metadata_handle,
        full_secs_out: *mut i64,
        frac_secs_out: *mut f64,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get last event code"]
    pub fn uhd_async_metadata_event_code(
        h: uhd_async_metadata_handle,
        event_code_out: *mut uhd_async_metadata_event_code_t,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get payload from custom FPGA fabric"]
    pub fn uhd_async_metadata_user_payload(
        h: uhd_async_metadata_handle,
        user_payload_out: *mut u32,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the last error logged by the async metadata object.\n*!\n* NOTE: This function will overwrite any string in the given buffer before\n* inserting the error string.\n*\n* \\param h metadata handle\n* \\param error_out string buffer for error\n* \\param strbuffer_len buffer length\n*/"]
    pub fn uhd_async_metadata_last_error(
        h: uhd_async_metadata_handle,
        error_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
#[doc = "! Range of floating-point values"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_range_t {
    #[doc = "! First value"]
    pub start: f64,
    #[doc = "! Last value"]
    pub stop: f64,
    #[doc = "! Granularity"]
    pub step: f64,
}
#[test]
fn bindgen_test_layout_uhd_range_t() {
    const UNINIT: ::std::mem::MaybeUninit<uhd_range_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uhd_range_t>(),
        24usize,
        concat!("Size of: ", stringify!(uhd_range_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uhd_range_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uhd_range_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).start) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_range_t),
            "::",
            stringify!(start)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stop) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_range_t),
            "::",
            stringify!(stop)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).step) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_range_t),
            "::",
            stringify!(step)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_meta_range_t {
    _unused: [u8; 0],
}
#[doc = "! C-level interface for dealing with a list of ranges\n*!\n* See uhd::meta_range_t for more details.\n*/"]
pub type uhd_meta_range_handle = *mut uhd_meta_range_t;
extern "C" {
    #[doc = "! Get a string representation of the given range"]
    pub fn uhd_range_to_pp_string(
        range: *const uhd_range_t,
        pp_string_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Create a meta range handle\n*!\n* NOTE: Using a uhd_meta_range_handle before passing it into this function will\n* result in undefined behavior.\n*/"]
    pub fn uhd_meta_range_make(h: *mut uhd_meta_range_handle) -> uhd_error;
}
extern "C" {
    #[doc = "! Destroy a meta range handle\n*!\n* NOTE: Using a uhd_meta_range_handle after passing it into this function will\n* result in a segmentation fault.\n*/"]
    pub fn uhd_meta_range_free(h: *mut uhd_meta_range_handle) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the overall start value for the given meta range"]
    pub fn uhd_meta_range_start(h: uhd_meta_range_handle, start_out: *mut f64) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the overall stop value for the given meta range"]
    pub fn uhd_meta_range_stop(h: uhd_meta_range_handle, stop_out: *mut f64) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the overall step value for the given meta range"]
    pub fn uhd_meta_range_step(h: uhd_meta_range_handle, step_out: *mut f64) -> uhd_error;
}
extern "C" {
    #[doc = "! Clip the given value to a possible value in the given range"]
    pub fn uhd_meta_range_clip(
        h: uhd_meta_range_handle,
        value: f64,
        clip_step: bool,
        result_out: *mut f64,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the number of ranges in the given meta range"]
    pub fn uhd_meta_range_size(h: uhd_meta_range_handle, size_out: *mut usize) -> uhd_error;
}
extern "C" {
    #[doc = "! Add a range to the given meta range"]
    pub fn uhd_meta_range_push_back(
        h: uhd_meta_range_handle,
        range: *const uhd_range_t,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the range at the given index"]
    pub fn uhd_meta_range_at(
        h: uhd_meta_range_handle,
        num: usize,
        range_out: *mut uhd_range_t,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get a string representation of the given meta range"]
    pub fn uhd_meta_range_to_pp_string(
        h: uhd_meta_range_handle,
        pp_string_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the last error recorded by the underlying meta range"]
    pub fn uhd_meta_range_last_error(
        h: uhd_meta_range_handle,
        error_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_sensor_value_t {
    _unused: [u8; 0],
}
#[doc = "! C-level interface for a UHD sensor\n*!\n* See uhd::sensor_value_t for more details.\n*\n* NOTE: Using a handle before calling a make function will result in undefined behavior.\n*/"]
pub type uhd_sensor_value_handle = *mut uhd_sensor_value_t;
pub const uhd_sensor_value_data_type_t_UHD_SENSOR_VALUE_BOOLEAN: uhd_sensor_value_data_type_t = 98;
pub const uhd_sensor_value_data_type_t_UHD_SENSOR_VALUE_INTEGER: uhd_sensor_value_data_type_t = 105;
pub const uhd_sensor_value_data_type_t_UHD_SENSOR_VALUE_REALNUM: uhd_sensor_value_data_type_t = 114;
pub const uhd_sensor_value_data_type_t_UHD_SENSOR_VALUE_STRING: uhd_sensor_value_data_type_t = 115;
#[doc = "! Sensor value types"]
pub type uhd_sensor_value_data_type_t = ::std::os::raw::c_int;
extern "C" {
    #[doc = "! Make an empty UHD sensor value.\n*!\n* The purpose of this call is to populate the handle with a valid sensor value\n* object. Querying this object will always yield 'false'. Typically, this\n* sensor value object will never be used, but it will allow the handle object\n* to be used with sensor functions later on.\n*\n* \\param h the sensor handle in which to place sensor\n* \\returns UHD error code\n*/"]
    pub fn uhd_sensor_value_make(h: *mut uhd_sensor_value_handle) -> uhd_error;
}
extern "C" {
    #[doc = "! Make a UHD sensor from a boolean.\n*!\n* \\param h the sensor handle in which to place sensor\n* \\param name sensor name\n* \\param value sensor value\n* \\param utrue string representing \"true\"\n* \\param ufalse string representing \"false\"\n* \\returns UHD error code\n*/"]
    pub fn uhd_sensor_value_make_from_bool(
        h: *mut uhd_sensor_value_handle,
        name: *const ::std::os::raw::c_char,
        value: bool,
        utrue: *const ::std::os::raw::c_char,
        ufalse: *const ::std::os::raw::c_char,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Make a UHD sensor from an integer.\n*!\n* \\param h the sensor value in which to place sensor\n* \\param name sensor name\n* \\param value sensor value\n* \\param unit sensor unit\n* \\param formatter printf-style format string for value string\n* \\returns UHD error code\n*/"]
    pub fn uhd_sensor_value_make_from_int(
        h: *mut uhd_sensor_value_handle,
        name: *const ::std::os::raw::c_char,
        value: ::std::os::raw::c_int,
        unit: *const ::std::os::raw::c_char,
        formatter: *const ::std::os::raw::c_char,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Make a UHD sensor from a real number.\n*!\n* \\param h the sensor value in which to place sensor\n* \\param name sensor name\n* \\param value sensor value\n* \\param unit sensor unit\n* \\param formatter printf-style format string for value string\n* \\returns UHD error code\n*/"]
    pub fn uhd_sensor_value_make_from_realnum(
        h: *mut uhd_sensor_value_handle,
        name: *const ::std::os::raw::c_char,
        value: f64,
        unit: *const ::std::os::raw::c_char,
        formatter: *const ::std::os::raw::c_char,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Make a UHD sensor from a string.\n*!\n* \\param h the sensor value in which to place sensor\n* \\param name sensor name\n* \\param value sensor value\n* \\param unit sensor unit\n* \\returns UHD error code\n*/"]
    pub fn uhd_sensor_value_make_from_string(
        h: *mut uhd_sensor_value_handle,
        name: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
        unit: *const ::std::os::raw::c_char,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Free the given sensor handle.\n*!\n* Attempting to use the handle after calling this handle will\n* result in a segmentation fault.\n*/"]
    pub fn uhd_sensor_value_free(h: *mut uhd_sensor_value_handle) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the sensor's value as a boolean."]
    pub fn uhd_sensor_value_to_bool(h: uhd_sensor_value_handle, value_out: *mut bool) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the sensor's value as an integer."]
    pub fn uhd_sensor_value_to_int(
        h: uhd_sensor_value_handle,
        value_out: *mut ::std::os::raw::c_int,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the sensor's value as a real number."]
    pub fn uhd_sensor_value_to_realnum(
        h: uhd_sensor_value_handle,
        value_out: *mut f64,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the sensor's name.\n*!\n* NOTE: This function will overwrite any string in the given\n* buffer before inserting the sensor name.\n*\n* \\param h sensor handle\n* \\param name_out string buffer in which to place name\n* \\param strbuffer_len buffer length\n*/"]
    pub fn uhd_sensor_value_name(
        h: uhd_sensor_value_handle,
        name_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the sensor's value.\n*!\n* NOTE: This function will overwrite any string in the given\n* buffer before inserting the sensor value.\n*\n* \\param h sensor handle\n* \\param value_out string buffer in which to place value\n* \\param strbuffer_len buffer length\n*/"]
    pub fn uhd_sensor_value_value(
        h: uhd_sensor_value_handle,
        value_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the sensor's unit.\n*!\n* NOTE: This function will overwrite any string in the given\n* buffer before inserting the sensor unit.\n*\n* \\param h sensor handle\n* \\param unit_out string buffer in which to place unit\n* \\param strbuffer_len buffer length\n*/"]
    pub fn uhd_sensor_value_unit(
        h: uhd_sensor_value_handle,
        unit_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    pub fn uhd_sensor_value_data_type(
        h: uhd_sensor_value_handle,
        data_type_out: *mut uhd_sensor_value_data_type_t,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get a pretty-print representation of the given sensor.\n*!\n* NOTE: This function will overwrite any string in the given\n* buffer before inserting the string.\n*\n* \\param h sensor handle\n* \\param pp_string_out string buffer in which to place pp_string\n* \\param strbuffer_len buffer length\n*/"]
    pub fn uhd_sensor_value_to_pp_string(
        h: uhd_sensor_value_handle,
        pp_string_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the last error logged by the sensor handle.\n*!\n* NOTE: This function will overwrite any string in the given\n* buffer before inserting the error string.\n*\n* \\param h sensor handle\n* \\param error_out string buffer in which to place error\n* \\param strbuffer_len buffer length\n*/"]
    pub fn uhd_sensor_value_last_error(
        h: uhd_sensor_value_handle,
        error_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
#[doc = "! C-level read-only interface for interacting with a string vector"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_string_vector_t {
    _unused: [u8; 0],
}

pub type uhd_string_vector_handle = *mut uhd_string_vector_t;
extern "C" {
    #[doc = "! Instantiate a string_vector handle."]
    pub fn uhd_string_vector_make(h: *mut uhd_string_vector_handle) -> uhd_error;
}
extern "C" {
    #[doc = "! Safely destroy a string_vector handle."]
    pub fn uhd_string_vector_free(h: *mut uhd_string_vector_handle) -> uhd_error;
}
extern "C" {
    #[doc = "! Add a string to the list"]
    pub fn uhd_string_vector_push_back(
        h: *mut uhd_string_vector_handle,
        value: *const ::std::os::raw::c_char,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the string at the given index"]
    pub fn uhd_string_vector_at(
        h: uhd_string_vector_handle,
        index: usize,
        value_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the number of strings in this list"]
    pub fn uhd_string_vector_size(h: uhd_string_vector_handle, size_out: *mut usize) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the last error reported by the underlying object"]
    pub fn uhd_string_vector_last_error(
        h: uhd_string_vector_handle,
        error_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
#[doc = "! Do not set this argument, use current setting."]
pub const uhd_tune_request_policy_t_UHD_TUNE_REQUEST_POLICY_NONE: uhd_tune_request_policy_t = 78;
#[doc = "! Automatically determine the argument's value."]
pub const uhd_tune_request_policy_t_UHD_TUNE_REQUEST_POLICY_AUTO: uhd_tune_request_policy_t = 65;
#[doc = "! Use the argument's value for the setting."]
pub const uhd_tune_request_policy_t_UHD_TUNE_REQUEST_POLICY_MANUAL: uhd_tune_request_policy_t = 77;
#[doc = "! Policy options for tunable elements in the RF chain."]
pub type uhd_tune_request_policy_t = ::std::os::raw::c_int;
#[doc = "! Instructs implementation how to tune the RF chain\n*!\n* See uhd::tune_request_t for more details.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_tune_request_t {
    #[doc = "! Target frequency for RF chain in Hz"]
    pub target_freq: f64,
    #[doc = "! RF frequency policy"]
    pub rf_freq_policy: uhd_tune_request_policy_t,
    #[doc = "! RF frequency in Hz"]
    pub rf_freq: f64,
    #[doc = "! DSP frequency policy"]
    pub dsp_freq_policy: uhd_tune_request_policy_t,
    #[doc = "! DSP frequency in Hz"]
    pub dsp_freq: f64,
    #[doc = "! Key-value pairs delimited by commas"]
    pub args: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_uhd_tune_request_t() {
    const UNINIT: ::std::mem::MaybeUninit<uhd_tune_request_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uhd_tune_request_t>(),
        48usize,
        concat!("Size of: ", stringify!(uhd_tune_request_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uhd_tune_request_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uhd_tune_request_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_freq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_tune_request_t),
            "::",
            stringify!(target_freq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rf_freq_policy) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_tune_request_t),
            "::",
            stringify!(rf_freq_policy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rf_freq) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_tune_request_t),
            "::",
            stringify!(rf_freq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dsp_freq_policy) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_tune_request_t),
            "::",
            stringify!(dsp_freq_policy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dsp_freq) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_tune_request_t),
            "::",
            stringify!(dsp_freq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).args) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_tune_request_t),
            "::",
            stringify!(args)
        )
    );
}
#[doc = "! Stores RF and DSP tuned frequencies.\n*!\n* See uhd::tune_result_t for more details.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_tune_result_t {
    #[doc = "! Target RF frequency, clipped to be within system range"]
    pub clipped_rf_freq: f64,
    #[doc = "! Target RF frequency, including RF FE offset"]
    pub target_rf_freq: f64,
    #[doc = "! Frequency to which RF LO is actually tuned"]
    pub actual_rf_freq: f64,
    #[doc = "! Frequency the CORDIC must adjust the RF"]
    pub target_dsp_freq: f64,
    #[doc = "! Frequency to which the CORDIC in the DSP actually tuned"]
    pub actual_dsp_freq: f64,
}
#[test]
fn bindgen_test_layout_uhd_tune_result_t() {
    const UNINIT: ::std::mem::MaybeUninit<uhd_tune_result_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uhd_tune_result_t>(),
        40usize,
        concat!("Size of: ", stringify!(uhd_tune_result_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uhd_tune_result_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uhd_tune_result_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clipped_rf_freq) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_tune_result_t),
            "::",
            stringify!(clipped_rf_freq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_rf_freq) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_tune_result_t),
            "::",
            stringify!(target_rf_freq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).actual_rf_freq) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_tune_result_t),
            "::",
            stringify!(actual_rf_freq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).target_dsp_freq) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_tune_result_t),
            "::",
            stringify!(target_dsp_freq)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).actual_dsp_freq) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_tune_result_t),
            "::",
            stringify!(actual_dsp_freq)
        )
    );
}
extern "C" {
    #[doc = "! Create a pretty print representation of this tune result."]
    pub fn uhd_tune_result_to_pp_string(
        tune_result: *mut uhd_tune_result_t,
        pp_string_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    );
}
#[doc = "! USRP RX info\n*!\n* This struct is populated by uhd_usrp_get_rx_info().\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_usrp_rx_info_t {
    #[doc = "! Motherboard ID"]
    pub mboard_id: *mut ::std::os::raw::c_char,
    #[doc = "! Motherboard name"]
    pub mboard_name: *mut ::std::os::raw::c_char,
    #[doc = "! Motherboard serial"]
    pub mboard_serial: *mut ::std::os::raw::c_char,
    #[doc = "! RX daughterboard ID"]
    pub rx_id: *mut ::std::os::raw::c_char,
    #[doc = "! RX subdev name"]
    pub rx_subdev_name: *mut ::std::os::raw::c_char,
    #[doc = "! RX subdev spec"]
    pub rx_subdev_spec: *mut ::std::os::raw::c_char,
    #[doc = "! RX daughterboard serial"]
    pub rx_serial: *mut ::std::os::raw::c_char,
    #[doc = "! RX daughterboard antenna"]
    pub rx_antenna: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_uhd_usrp_rx_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<uhd_usrp_rx_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uhd_usrp_rx_info_t>(),
        64usize,
        concat!("Size of: ", stringify!(uhd_usrp_rx_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uhd_usrp_rx_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uhd_usrp_rx_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mboard_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_rx_info_t),
            "::",
            stringify!(mboard_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mboard_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_rx_info_t),
            "::",
            stringify!(mboard_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mboard_serial) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_rx_info_t),
            "::",
            stringify!(mboard_serial)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_rx_info_t),
            "::",
            stringify!(rx_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_subdev_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_rx_info_t),
            "::",
            stringify!(rx_subdev_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_subdev_spec) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_rx_info_t),
            "::",
            stringify!(rx_subdev_spec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_serial) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_rx_info_t),
            "::",
            stringify!(rx_serial)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_antenna) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_rx_info_t),
            "::",
            stringify!(rx_antenna)
        )
    );
}
#[doc = "! USRP TX info\n*!\n* This struct is populated by uhd_usrp_get_tx_info().\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_usrp_tx_info_t {
    #[doc = "! Motherboard ID"]
    pub mboard_id: *mut ::std::os::raw::c_char,
    #[doc = "! Motherboard name"]
    pub mboard_name: *mut ::std::os::raw::c_char,
    #[doc = "! Motherboard serial"]
    pub mboard_serial: *mut ::std::os::raw::c_char,
    #[doc = "! TX daughterboard ID"]
    pub tx_id: *mut ::std::os::raw::c_char,
    #[doc = "! TX subdev name"]
    pub tx_subdev_name: *mut ::std::os::raw::c_char,
    #[doc = "! TX subdev spec"]
    pub tx_subdev_spec: *mut ::std::os::raw::c_char,
    #[doc = "! TX daughterboard serial"]
    pub tx_serial: *mut ::std::os::raw::c_char,
    #[doc = "! TX daughterboard antenna"]
    pub tx_antenna: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_uhd_usrp_tx_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<uhd_usrp_tx_info_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uhd_usrp_tx_info_t>(),
        64usize,
        concat!("Size of: ", stringify!(uhd_usrp_tx_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uhd_usrp_tx_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uhd_usrp_tx_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mboard_id) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_tx_info_t),
            "::",
            stringify!(mboard_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mboard_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_tx_info_t),
            "::",
            stringify!(mboard_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mboard_serial) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_tx_info_t),
            "::",
            stringify!(mboard_serial)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_id) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_tx_info_t),
            "::",
            stringify!(tx_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_subdev_name) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_tx_info_t),
            "::",
            stringify!(tx_subdev_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_subdev_spec) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_tx_info_t),
            "::",
            stringify!(tx_subdev_spec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_serial) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_tx_info_t),
            "::",
            stringify!(tx_serial)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_antenna) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_tx_info_t),
            "::",
            stringify!(tx_antenna)
        )
    );
}
extern "C" {
    #[doc = "! Clean up a uhd_usrp_rx_info_t populated by uhd_usrp_get_rx_info().\n*!\n* NOTE: If this function is passed a uhd_usrp_rx_info_t that has not\n* been populated by uhd_usrp_get_rx_info(), it will produce a double-free\n* error.\n*/"]
    pub fn uhd_usrp_rx_info_free(rx_info: *mut uhd_usrp_rx_info_t) -> uhd_error;
}
extern "C" {
    #[doc = "! Clean up a uhd_usrp_tx_info_t populated by uhd_usrp_get_tx_info().\n*!\n* NOTE: If this function is passed a uhd_usrp_tx_info_t that has not\n* been populated by uhd_usrp_get_tx_info(), it will produce a double-free\n* error.\n*/"]
    pub fn uhd_usrp_tx_info_free(tx_info: *mut uhd_usrp_tx_info_t) -> uhd_error;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_dboard_eeprom_t {
    _unused: [u8; 0],
}
#[doc = "! A C-level interface for interacting with a daughterboard EEPROM\n*!\n* See uhd::usrp::dboard_eeprom_t for more details.\n*\n* NOTE: Using a handle before passing it into uhd_dboard_eeprom_make() will\n* result in undefined behavior.\n*/"]
pub type uhd_dboard_eeprom_handle = *mut uhd_dboard_eeprom_t;
extern "C" {
    #[doc = "! Create handle for a USRP daughterboard EEPROM"]
    pub fn uhd_dboard_eeprom_make(h: *mut uhd_dboard_eeprom_handle) -> uhd_error;
}
extern "C" {
    #[doc = "! Safely destroy the given handle\n*!\n* NOTE: Using a handle after passing it into this function will result in\n* a segmentation fault.\n*/"]
    pub fn uhd_dboard_eeprom_free(h: *mut uhd_dboard_eeprom_handle) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the ID associated with the given daughterboard as a string hex representation"]
    pub fn uhd_dboard_eeprom_get_id(
        h: uhd_dboard_eeprom_handle,
        id_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set the daughterboard ID using a string hex representation"]
    pub fn uhd_dboard_eeprom_set_id(
        h: uhd_dboard_eeprom_handle,
        id: *const ::std::os::raw::c_char,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the daughterboard's serial"]
    pub fn uhd_dboard_eeprom_get_serial(
        h: uhd_dboard_eeprom_handle,
        serial_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set the daughterboard's serial"]
    pub fn uhd_dboard_eeprom_set_serial(
        h: uhd_dboard_eeprom_handle,
        serial: *const ::std::os::raw::c_char,
    ) -> uhd_error;
}
extern "C" {
    #[doc = " Get the daughterboard's revision\n\n The revision doesn't always have to be present, in which case this function\n will return an error."]
    pub fn uhd_dboard_eeprom_get_revision(
        h: uhd_dboard_eeprom_handle,
        revision_out: *mut ::std::os::raw::c_int,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set the daughterboard's revision"]
    pub fn uhd_dboard_eeprom_set_revision(
        h: uhd_dboard_eeprom_handle,
        revision: ::std::os::raw::c_int,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the last error reported by the handle"]
    pub fn uhd_dboard_eeprom_last_error(
        h: uhd_dboard_eeprom_handle,
        error_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_mboard_eeprom_t {
    _unused: [u8; 0],
}
#[doc = "! A C-level interface for interacting with a USRP motherboard's EEPROM\n*!\n* See uhd::usrp::mboard_eeprom_t for more details.\n*\n* NOTE: Using a handle before passing it into uhd_mboard_eeprom_make() will\n* result in undefined behavior.\n*/"]
pub type uhd_mboard_eeprom_handle = *mut uhd_mboard_eeprom_t;
extern "C" {
    #[doc = "! Create a handle for working with a USRP motherboard EEPROM"]
    pub fn uhd_mboard_eeprom_make(h: *mut uhd_mboard_eeprom_handle) -> uhd_error;
}
extern "C" {
    #[doc = "! Free a USRP motherboard EEPROM handle\n*!\n* NOTE: Using a handle after passing it into this function will result in\n* a segmentation fault.\n*/"]
    pub fn uhd_mboard_eeprom_free(h: *mut uhd_mboard_eeprom_handle) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the value associated with the given EEPROM key"]
    pub fn uhd_mboard_eeprom_get_value(
        h: uhd_mboard_eeprom_handle,
        key: *const ::std::os::raw::c_char,
        value_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set the value for the given EEPROM key"]
    pub fn uhd_mboard_eeprom_set_value(
        h: uhd_mboard_eeprom_handle,
        key: *const ::std::os::raw::c_char,
        value: *const ::std::os::raw::c_char,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the last error recorded by the handle"]
    pub fn uhd_mboard_eeprom_last_error(
        h: uhd_mboard_eeprom_handle,
        error_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
#[doc = "! Subdevice specification"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_subdev_spec_pair_t {
    pub db_name: *mut ::std::os::raw::c_char,
    #[doc = "! Subdevice name"]
    pub sd_name: *mut ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_uhd_subdev_spec_pair_t() {
    const UNINIT: ::std::mem::MaybeUninit<uhd_subdev_spec_pair_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uhd_subdev_spec_pair_t>(),
        16usize,
        concat!("Size of: ", stringify!(uhd_subdev_spec_pair_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uhd_subdev_spec_pair_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uhd_subdev_spec_pair_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).db_name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_subdev_spec_pair_t),
            "::",
            stringify!(db_name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sd_name) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_subdev_spec_pair_t),
            "::",
            stringify!(sd_name)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_subdev_spec_t {
    _unused: [u8; 0],
}
#[doc = "! A C-level interface for working with a list of subdevice specifications\n*!\n* See uhd::usrp::subdev_spec_t for more details.\n*\n* NOTE: Using a handle before passing it into uhd_subdev_spec_make() will result in\n* undefined behavior.\n*/"]
pub type uhd_subdev_spec_handle = *mut uhd_subdev_spec_t;
extern "C" {
    #[doc = "! Safely destroy any memory created in the generation of a uhd_subdev_spec_pair_t"]
    pub fn uhd_subdev_spec_pair_free(subdev_spec_pair: *mut uhd_subdev_spec_pair_t) -> uhd_error;
}
extern "C" {
    #[doc = "! Check to see if two subdevice specifications are equal"]
    pub fn uhd_subdev_spec_pairs_equal(
        first: *const uhd_subdev_spec_pair_t,
        second: *const uhd_subdev_spec_pair_t,
        result_out: *mut bool,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Create a handle for a list of subdevice specifications"]
    pub fn uhd_subdev_spec_make(
        h: *mut uhd_subdev_spec_handle,
        markup: *const ::std::os::raw::c_char,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Safely destroy a subdevice specification handle\n*!\n* NOTE: Using a handle after passing it into this function will result in\n* a segmentation fault.\n*/"]
    pub fn uhd_subdev_spec_free(h: *mut uhd_subdev_spec_handle) -> uhd_error;
}
extern "C" {
    #[doc = "! Check how many subdevice specifications are in this list"]
    pub fn uhd_subdev_spec_size(h: uhd_subdev_spec_handle, size_out: *mut usize) -> uhd_error;
}
extern "C" {
    #[doc = "! Add a subdevice specification to this list"]
    pub fn uhd_subdev_spec_push_back(
        h: uhd_subdev_spec_handle,
        markup: *const ::std::os::raw::c_char,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the subdevice specification at the given index"]
    pub fn uhd_subdev_spec_at(
        h: uhd_subdev_spec_handle,
        num: usize,
        subdev_spec_pair_out: *mut uhd_subdev_spec_pair_t,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get a string representation of the given list"]
    pub fn uhd_subdev_spec_to_pp_string(
        h: uhd_subdev_spec_handle,
        pp_string_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get a markup string representation of the given list"]
    pub fn uhd_subdev_spec_to_string(
        h: uhd_subdev_spec_handle,
        string_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the last error recorded by the given handle"]
    pub fn uhd_subdev_spec_last_error(
        h: uhd_subdev_spec_handle,
        error_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
#[doc = "! Register info"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_usrp_register_info_t {
    pub bitwidth: usize,
    pub readable: bool,
    pub writable: bool,
}
#[test]
fn bindgen_test_layout_uhd_usrp_register_info_t() {
    const UNINIT: ::std::mem::MaybeUninit<uhd_usrp_register_info_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uhd_usrp_register_info_t>(),
        16usize,
        concat!("Size of: ", stringify!(uhd_usrp_register_info_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uhd_usrp_register_info_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uhd_usrp_register_info_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bitwidth) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_register_info_t),
            "::",
            stringify!(bitwidth)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).readable) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_register_info_t),
            "::",
            stringify!(readable)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).writable) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_usrp_register_info_t),
            "::",
            stringify!(writable)
        )
    );
}
#[doc = "! A struct of parameters to construct a stream.\n*!\n* See uhd::stream_args_t for more details.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_stream_args_t {
    #[doc = "! Format of host memory"]
    pub cpu_format: *mut ::std::os::raw::c_char,
    #[doc = "! Over-the-wire format"]
    pub otw_format: *mut ::std::os::raw::c_char,
    #[doc = "! Other stream args"]
    pub args: *mut ::std::os::raw::c_char,
    #[doc = "! Array that lists channels"]
    pub channel_list: *mut usize,
    #[doc = "! Number of channels"]
    pub n_channels: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_uhd_stream_args_t() {
    const UNINIT: ::std::mem::MaybeUninit<uhd_stream_args_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uhd_stream_args_t>(),
        40usize,
        concat!("Size of: ", stringify!(uhd_stream_args_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uhd_stream_args_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uhd_stream_args_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cpu_format) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_stream_args_t),
            "::",
            stringify!(cpu_format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).otw_format) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_stream_args_t),
            "::",
            stringify!(otw_format)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).args) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_stream_args_t),
            "::",
            stringify!(args)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel_list) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_stream_args_t),
            "::",
            stringify!(channel_list)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_channels) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_stream_args_t),
            "::",
            stringify!(n_channels)
        )
    );
}
#[doc = "! Stream samples indefinitely"]
pub const uhd_stream_mode_t_UHD_STREAM_MODE_START_CONTINUOUS: uhd_stream_mode_t = 97;
#[doc = "! End continuous streaming"]
pub const uhd_stream_mode_t_UHD_STREAM_MODE_STOP_CONTINUOUS: uhd_stream_mode_t = 111;
#[doc = "! Stream some number of samples and finish"]
pub const uhd_stream_mode_t_UHD_STREAM_MODE_NUM_SAMPS_AND_DONE: uhd_stream_mode_t = 100;
#[doc = "! Stream some number of samples but expect more"]
pub const uhd_stream_mode_t_UHD_STREAM_MODE_NUM_SAMPS_AND_MORE: uhd_stream_mode_t = 109;
#[doc = "! How streaming is issued to the device\n*!\n* See uhd::stream_cmd_t for more details.\n*/"]
pub type uhd_stream_mode_t = ::std::os::raw::c_int;
#[doc = "! Define how device streams to host\n*!\n* See uhd::stream_cmd_t for more details.\n*/"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_stream_cmd_t {
    #[doc = "! How streaming is issued to the device"]
    pub stream_mode: uhd_stream_mode_t,
    #[doc = "! Number of samples"]
    pub num_samps: usize,
    #[doc = "! Stream now?"]
    pub stream_now: bool,
    #[doc = "! If not now, then full seconds into future to stream"]
    pub time_spec_full_secs: i64,
    #[doc = "! If not now, then fractional seconds into future to stream"]
    pub time_spec_frac_secs: f64,
}
#[test]
fn bindgen_test_layout_uhd_stream_cmd_t() {
    const UNINIT: ::std::mem::MaybeUninit<uhd_stream_cmd_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<uhd_stream_cmd_t>(),
        40usize,
        concat!("Size of: ", stringify!(uhd_stream_cmd_t))
    );
    assert_eq!(
        ::std::mem::align_of::<uhd_stream_cmd_t>(),
        8usize,
        concat!("Alignment of ", stringify!(uhd_stream_cmd_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_mode) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_stream_cmd_t),
            "::",
            stringify!(stream_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_samps) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_stream_cmd_t),
            "::",
            stringify!(num_samps)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stream_now) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_stream_cmd_t),
            "::",
            stringify!(stream_now)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_spec_full_secs) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_stream_cmd_t),
            "::",
            stringify!(time_spec_full_secs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_spec_frac_secs) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(uhd_stream_cmd_t),
            "::",
            stringify!(time_spec_frac_secs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_rx_streamer {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_tx_streamer {
    _unused: [u8; 0],
}
#[doc = "! C-level interface for working with an RX streamer\n*!\n* See uhd::rx_streamer for more details.\n*/"]
pub type uhd_rx_streamer_handle = *mut uhd_rx_streamer;
#[doc = "! C-level interface for working with a TX streamer\n*!\n* See uhd::tx_streamer for more details.\n*/"]
pub type uhd_tx_streamer_handle = *mut uhd_tx_streamer;
extern "C" {
    #[doc = "! Create an RX streamer handle.\n*!\n* NOTE: Using this streamer before passing it into uhd_usrp_get_rx_stream()\n* will result in undefined behavior.\n*/"]
    pub fn uhd_rx_streamer_make(h: *mut uhd_rx_streamer_handle) -> uhd_error;
}
extern "C" {
    #[doc = "! Free an RX streamer handle.\n*!\n* NOTE: Using a streamer after passing it into this function will result\n* in a segmentation fault.\n*/"]
    pub fn uhd_rx_streamer_free(h: *mut uhd_rx_streamer_handle) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the number of channels associated with this streamer"]
    pub fn uhd_rx_streamer_num_channels(
        h: uhd_rx_streamer_handle,
        num_channels_out: *mut usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the max number of samples per buffer per packet"]
    pub fn uhd_rx_streamer_max_num_samps(
        h: uhd_rx_streamer_handle,
        max_num_samps_out: *mut usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Receive buffers containing samples into the given RX streamer\n*!\n* See uhd::rx_streamer::recv() for more details.\n*\n* \\param h RX streamer handle\n* \\param buffs pointer to buffers in which to receive samples\n* \\param samps_per_buff max number of samples per buffer\n* \\param md handle to RX metadata in which to receive results\n* \\param timeout timeout in seconds to wait for a packet\n* \\param one_packet send a single packet\n* \\param items_recvd pointer to output variable for number of samples received\n*/"]
    pub fn uhd_rx_streamer_recv(
        h: uhd_rx_streamer_handle,
        buffs: *mut *mut ::std::os::raw::c_void,
        samps_per_buff: usize,
        md: *mut uhd_rx_metadata_handle,
        timeout: f64,
        one_packet: bool,
        items_recvd: *mut usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Issue the given stream command\n*!\n* See uhd::rx_streamer::issue_stream_cmd() for more details.\n*/"]
    pub fn uhd_rx_streamer_issue_stream_cmd(
        h: uhd_rx_streamer_handle,
        stream_cmd: *const uhd_stream_cmd_t,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the last error reported by the RX streamer\n*!\n* NOTE: This will overwrite the string currently in error_out before\n* using it to return its error.\n*\n* \\param h RX streamer handle\n* \\param error_out string buffer in which to place error\n* \\param strbuffer_len buffer size\n*/"]
    pub fn uhd_rx_streamer_last_error(
        h: uhd_rx_streamer_handle,
        error_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Create an TX streamer handle.\n*!\n* NOTE: Using this streamer before passing it into uhd_usrp_get_tx_stream()\n* will result in undefined behavior.\n*/"]
    pub fn uhd_tx_streamer_make(h: *mut uhd_tx_streamer_handle) -> uhd_error;
}
extern "C" {
    #[doc = "! Free an TX streamer handle.\n*!\n* NOTE: Using a streamer after passing it into this function will result\n* in a segmentation fault.\n*/"]
    pub fn uhd_tx_streamer_free(h: *mut uhd_tx_streamer_handle) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the number of channels associated with this streamer"]
    pub fn uhd_tx_streamer_num_channels(
        h: uhd_tx_streamer_handle,
        num_channels_out: *mut usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the max number of samples per buffer per packet"]
    pub fn uhd_tx_streamer_max_num_samps(
        h: uhd_tx_streamer_handle,
        max_num_samps_out: *mut usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Send buffers containing samples described by the metadata\n*!\n* See uhd::tx_streamer::send() for more details.\n*\n* \\param h TX streamer handle\n* \\param buffs pointer to buffers containing samples to send\n* \\param samps_per_buff max number of samples per buffer\n* \\param md handle to TX metadata\n* \\param timeout timeout in seconds to wait for a packet\n* \\param items_sent pointer to output variable for number of samples send\n*/"]
    pub fn uhd_tx_streamer_send(
        h: uhd_tx_streamer_handle,
        buffs: *mut *const ::std::os::raw::c_void,
        samps_per_buff: usize,
        md: *mut uhd_tx_metadata_handle,
        timeout: f64,
        items_sent: *mut usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Receive an asynchronous message from this streamer\n*!\n* See uhd::tx_streamer::recv_async_msg() for more details.\n*/"]
    pub fn uhd_tx_streamer_recv_async_msg(
        h: uhd_tx_streamer_handle,
        md: *mut uhd_async_metadata_handle,
        timeout: f64,
        valid: *mut bool,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the last error reported by the TX streamer\n*!\n* NOTE: This will overwrite the string currently in error_out before\n* using it to return its error.\n*\n* \\param h TX streamer handle\n* \\param error_out string buffer in which to place error\n* \\param strbuffer_len buffer size\n*/"]
    pub fn uhd_tx_streamer_last_error(
        h: uhd_tx_streamer_handle,
        error_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
#[doc = " Public Datatypes for USRP / streamer handling."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_usrp {
    _unused: [u8; 0],
}
#[doc = "! C-level interface for working with a USRP device"]
pub type uhd_usrp_handle = *mut uhd_usrp;
extern "C" {
    #[doc = "! Find all connected USRP devices.\n*!\n* See uhd::device::find() for more details.\n*/"]
    pub fn uhd_usrp_find(
        args: *const ::std::os::raw::c_char,
        strings_out: *mut uhd_string_vector_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Create a USRP handle.\n*!\n* \\param h the handle\n* \\param args device args (e.g. \"type=x300\")\n*/"]
    pub fn uhd_usrp_make(h: *mut uhd_usrp_handle, args: *const ::std::os::raw::c_char)
        -> uhd_error;
}
extern "C" {
    #[doc = "! Safely destroy the USRP object underlying the handle.\n*!\n* NOTE: Attempting to use a USRP handle after passing it into this function\n* will result in a segmentation fault.\n*/"]
    pub fn uhd_usrp_free(h: *mut uhd_usrp_handle) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the last error reported by the USRP handle"]
    pub fn uhd_usrp_last_error(
        h: uhd_usrp_handle,
        error_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Create RX streamer from a USRP handle and given stream args"]
    pub fn uhd_usrp_get_rx_stream(
        h: uhd_usrp_handle,
        stream_args: *mut uhd_stream_args_t,
        h_out: uhd_rx_streamer_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Create TX streamer from a USRP handle and given stream args"]
    pub fn uhd_usrp_get_tx_stream(
        h: uhd_usrp_handle,
        stream_args: *mut uhd_stream_args_t,
        h_out: uhd_tx_streamer_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get RX info from the USRP device\n*!\n* NOTE: After calling this function, uhd_usrp_rx_info_free() must be called on info_out.\n*/"]
    pub fn uhd_usrp_get_rx_info(
        h: uhd_usrp_handle,
        chan: usize,
        info_out: *mut uhd_usrp_rx_info_t,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get TX info from the USRP device\n*!\n* NOTE: After calling this function, uhd_usrp_tx_info_free() must be called on info_out.\n*/"]
    pub fn uhd_usrp_get_tx_info(
        h: uhd_usrp_handle,
        chan: usize,
        info_out: *mut uhd_usrp_tx_info_t,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set the master clock rate.\n*!\n* See uhd::usrp::multi_usrp::set_master_clock_rate() for more details.\n*/"]
    pub fn uhd_usrp_set_master_clock_rate(
        h: uhd_usrp_handle,
        rate: f64,
        mboard: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the master clock rate.\n*!\n* See uhd::usrp::multi_usrp::get_master_clock_rate() for more details.\n*/"]
    pub fn uhd_usrp_get_master_clock_rate(
        h: uhd_usrp_handle,
        mboard: usize,
        clock_rate_out: *mut f64,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get a pretty-print representation of the USRP device.\n*!\n* See uhd::usrp::multi_usrp::get_pp_string() for more details.\n*/"]
    pub fn uhd_usrp_get_pp_string(
        h: uhd_usrp_handle,
        pp_string_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the motherboard name for the given device\n*!\n* See uhd::usrp::multi_usrp::get_mboard_name() for more details.\n*/"]
    pub fn uhd_usrp_get_mboard_name(
        h: uhd_usrp_handle,
        mboard: usize,
        mboard_name_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the USRP device's current internal time\n*!\n* See uhd::usrp::multi_usrp::get_time_now() for more details.\n*/"]
    pub fn uhd_usrp_get_time_now(
        h: uhd_usrp_handle,
        mboard: usize,
        full_secs_out: *mut i64,
        frac_secs_out: *mut f64,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the time when this device's last PPS pulse occurred\n*!\n* See uhd::usrp::multi_usrp::get_time_last_pps() for more details.\n*/"]
    pub fn uhd_usrp_get_time_last_pps(
        h: uhd_usrp_handle,
        mboard: usize,
        full_secs_out: *mut i64,
        frac_secs_out: *mut f64,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set the USRP device's time\n*!\n* See uhd::usrp::multi_usrp::set_time_now() for more details.\n*/"]
    pub fn uhd_usrp_set_time_now(
        h: uhd_usrp_handle,
        full_secs: i64,
        frac_secs: f64,
        mboard: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set the USRP device's time to the given value upon the next PPS detection\n*!\n* See uhd::usrp::multi_usrp::set_time_next_pps() for more details.\n*/"]
    pub fn uhd_usrp_set_time_next_pps(
        h: uhd_usrp_handle,
        full_secs: i64,
        frac_secs: f64,
        mboard: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Synchronize the time across all motherboards\n*!\n* See uhd::usrp::multi_usrp::set_time_unknown_pps() for more details.\n*/"]
    pub fn uhd_usrp_set_time_unknown_pps(
        h: uhd_usrp_handle,
        full_secs: i64,
        frac_secs: f64,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Are all motherboard times synchronized?"]
    pub fn uhd_usrp_get_time_synchronized(h: uhd_usrp_handle, result_out: *mut bool) -> uhd_error;
}
extern "C" {
    #[doc = "! Set the time at which timed commands will take place\n*!\n* See uhd::usrp::multi_usrp::set_command_time() for more details.\n*/"]
    pub fn uhd_usrp_set_command_time(
        h: uhd_usrp_handle,
        full_secs: i64,
        frac_secs: f64,
        mboard: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Clear the command time so that commands are sent ASAP"]
    pub fn uhd_usrp_clear_command_time(h: uhd_usrp_handle, mboard: usize) -> uhd_error;
}
extern "C" {
    #[doc = "! Set the time source for the given device\n*!\n* See uhd::usrp::multi_usrp::set_time_source() for more details.\n*/"]
    pub fn uhd_usrp_set_time_source(
        h: uhd_usrp_handle,
        time_source: *const ::std::os::raw::c_char,
        mboard: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the time source for the given device\n*!\n* See uhd::usrp::multi_usrp::get_time_source() for more details.\n*/"]
    pub fn uhd_usrp_get_time_source(
        h: uhd_usrp_handle,
        mboard: usize,
        time_source_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get a list of time sources for the given device"]
    pub fn uhd_usrp_get_time_sources(
        h: uhd_usrp_handle,
        mboard: usize,
        time_sources_out: *mut uhd_string_vector_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set the given device's clock source\n*!\n* See uhd::usrp::multi_usrp::set_clock_source() for more details.\n*/"]
    pub fn uhd_usrp_set_clock_source(
        h: uhd_usrp_handle,
        clock_source: *const ::std::os::raw::c_char,
        mboard: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the given device's clock source\n*!\n* See uhd::usrp::multi_usrp::get_clock_source() for more details.\n*/"]
    pub fn uhd_usrp_get_clock_source(
        h: uhd_usrp_handle,
        mboard: usize,
        clock_source_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get a list of clock sources for the given device"]
    pub fn uhd_usrp_get_clock_sources(
        h: uhd_usrp_handle,
        mboard: usize,
        clock_sources_out: *mut uhd_string_vector_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Enable or disable sending the clock source to an output connector\n*!\n* See uhd::usrp::set_clock_source_out() for more details.\n*/"]
    pub fn uhd_usrp_set_clock_source_out(h: uhd_usrp_handle, enb: bool, mboard: usize)
        -> uhd_error;
}
extern "C" {
    #[doc = "! Enable or disable sending the time source to an output connector\n*!\n* See uhd::usrp::set_time_source_out() for more details.\n*/"]
    pub fn uhd_usrp_set_time_source_out(h: uhd_usrp_handle, enb: bool, mboard: usize) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the number of devices associated with the given USRP handle"]
    pub fn uhd_usrp_get_num_mboards(h: uhd_usrp_handle, num_mboards_out: *mut usize) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the value associated with the given sensor name"]
    pub fn uhd_usrp_get_mboard_sensor(
        h: uhd_usrp_handle,
        name: *const ::std::os::raw::c_char,
        mboard: usize,
        sensor_value_out: *mut uhd_sensor_value_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get a list of motherboard sensors for the given device"]
    pub fn uhd_usrp_get_mboard_sensor_names(
        h: uhd_usrp_handle,
        mboard: usize,
        mboard_sensor_names_out: *mut uhd_string_vector_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Perform a write on a user configuration register bus\n*!\n* See uhd::usrp::multi_usrp::set_user_register() for more details.\n*/"]
    pub fn uhd_usrp_set_user_register(
        h: uhd_usrp_handle,
        addr: u8,
        data: u32,
        mboard: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get a handle for the given motherboard's EEPROM"]
    pub fn uhd_usrp_get_mboard_eeprom(
        h: uhd_usrp_handle,
        mb_eeprom: uhd_mboard_eeprom_handle,
        mboard: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set values in the given motherboard's EEPROM"]
    pub fn uhd_usrp_set_mboard_eeprom(
        h: uhd_usrp_handle,
        mb_eeprom: uhd_mboard_eeprom_handle,
        mboard: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get a handle for the given device's daughterboard EEPROM"]
    pub fn uhd_usrp_get_dboard_eeprom(
        h: uhd_usrp_handle,
        db_eeprom: uhd_dboard_eeprom_handle,
        unit: *const ::std::os::raw::c_char,
        slot: *const ::std::os::raw::c_char,
        mboard: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set values in the given daughterboard's EEPROM"]
    pub fn uhd_usrp_set_dboard_eeprom(
        h: uhd_usrp_handle,
        db_eeprom: uhd_dboard_eeprom_handle,
        unit: *const ::std::os::raw::c_char,
        slot: *const ::std::os::raw::c_char,
        mboard: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Map the given device's RX frontend to a channel\n*!\n* See uhd::usrp::multi_usrp::set_rx_subdev_spec() for more details.\n*/"]
    pub fn uhd_usrp_set_rx_subdev_spec(
        h: uhd_usrp_handle,
        subdev_spec: uhd_subdev_spec_handle,
        mboard: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the RX frontend specification for the given device"]
    pub fn uhd_usrp_get_rx_subdev_spec(
        h: uhd_usrp_handle,
        mboard: usize,
        subdev_spec_out: uhd_subdev_spec_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the number of RX channels for the given handle"]
    pub fn uhd_usrp_get_rx_num_channels(
        h: uhd_usrp_handle,
        num_channels_out: *mut usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the name for the RX frontend"]
    pub fn uhd_usrp_get_rx_subdev_name(
        h: uhd_usrp_handle,
        chan: usize,
        rx_subdev_name_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set the given RX channel's sample rate (in Sps)"]
    pub fn uhd_usrp_set_rx_rate(h: uhd_usrp_handle, rate: f64, chan: usize) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the given RX channel's sample rate (in Sps)"]
    pub fn uhd_usrp_get_rx_rate(h: uhd_usrp_handle, chan: usize, rate_out: *mut f64) -> uhd_error;
}
extern "C" {
    #[doc = "! Get a range of possible RX rates for the given channel"]
    pub fn uhd_usrp_get_rx_rates(
        h: uhd_usrp_handle,
        chan: usize,
        rates_out: uhd_meta_range_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set the given channel's center RX frequency"]
    pub fn uhd_usrp_set_rx_freq(
        h: uhd_usrp_handle,
        tune_request: *mut uhd_tune_request_t,
        chan: usize,
        tune_result: *mut uhd_tune_result_t,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the given channel's center RX frequency"]
    pub fn uhd_usrp_get_rx_freq(h: uhd_usrp_handle, chan: usize, freq_out: *mut f64) -> uhd_error;
}
extern "C" {
    #[doc = "! Get all possible center frequency ranges for the given channel\n*!\n* See uhd::usrp::multi_usrp::get_rx_freq_range() for more details.\n*/"]
    pub fn uhd_usrp_get_rx_freq_range(
        h: uhd_usrp_handle,
        chan: usize,
        freq_range_out: uhd_meta_range_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get all possible RF frequency ranges for the given channel's RX RF frontend"]
    pub fn uhd_usrp_get_fe_rx_freq_range(
        h: uhd_usrp_handle,
        chan: usize,
        freq_range_out: uhd_meta_range_handle,
    ) -> uhd_error;
}
pub const UHD_USRP_ALL_LOS: &[u8; 4] = b"all\0";
extern "C" {
    #[doc = "! Get a list of possible LO stage names"]
    pub fn uhd_usrp_get_rx_lo_names(
        h: uhd_usrp_handle,
        chan: usize,
        rx_lo_names_out: *mut uhd_string_vector_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set the LO source for the USRP device"]
    pub fn uhd_usrp_set_rx_lo_source(
        h: uhd_usrp_handle,
        src: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        chan: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the currently set LO source"]
    pub fn uhd_usrp_get_rx_lo_source(
        h: uhd_usrp_handle,
        name: *const ::std::os::raw::c_char,
        chan: usize,
        rx_lo_source_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get a list of possible LO sources"]
    pub fn uhd_usrp_get_rx_lo_sources(
        h: uhd_usrp_handle,
        name: *const ::std::os::raw::c_char,
        chan: usize,
        rx_lo_sources_out: *mut uhd_string_vector_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set whether the LO used by the USRP device is exported"]
    pub fn uhd_usrp_set_rx_lo_export_enabled(
        h: uhd_usrp_handle,
        enabled: bool,
        name: *const ::std::os::raw::c_char,
        chan: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Returns true if the currently selected LO is being exported."]
    pub fn uhd_usrp_get_rx_lo_export_enabled(
        h: uhd_usrp_handle,
        name: *const ::std::os::raw::c_char,
        chan: usize,
        result_out: *mut bool,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set the RX LO frequency."]
    pub fn uhd_usrp_set_rx_lo_freq(
        h: uhd_usrp_handle,
        freq: f64,
        name: *const ::std::os::raw::c_char,
        chan: usize,
        coerced_freq_out: *mut f64,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the current RX LO frequency."]
    pub fn uhd_usrp_get_rx_lo_freq(
        h: uhd_usrp_handle,
        name: *const ::std::os::raw::c_char,
        chan: usize,
        rx_lo_freq_out: *mut f64,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set the RX gain for the given channel and name"]
    pub fn uhd_usrp_set_rx_gain(
        h: uhd_usrp_handle,
        gain: f64,
        chan: usize,
        gain_name: *const ::std::os::raw::c_char,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set the normalized RX gain [0.0, 1.0] for the given channel\n*!\n* See uhd::usrp::multi_usrp::set_normalized_rx_gain() for more details.\n*/"]
    pub fn uhd_usrp_set_normalized_rx_gain(h: uhd_usrp_handle, gain: f64, chan: usize)
        -> uhd_error;
}
extern "C" {
    #[doc = "! Enable or disable the given channel's RX AGC module\n*!\n* See uhd::usrp::multi_usrp::set_rx_agc() for more details.\n*/"]
    pub fn uhd_usrp_set_rx_agc(h: uhd_usrp_handle, enable: bool, chan: usize) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the given channel's RX gain"]
    pub fn uhd_usrp_get_rx_gain(
        h: uhd_usrp_handle,
        chan: usize,
        gain_name: *const ::std::os::raw::c_char,
        gain_out: *mut f64,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the given channel's normalized RX gain [0.0, 1.0]\n*!\n* See uhd::usrp::multi_usrp::get_normalized_rx_gain() for more details.\n*/"]
    pub fn uhd_usrp_get_normalized_rx_gain(
        h: uhd_usrp_handle,
        chan: usize,
        gain_out: *mut f64,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get all possible gain ranges for the given channel and name"]
    pub fn uhd_usrp_get_rx_gain_range(
        h: uhd_usrp_handle,
        name: *const ::std::os::raw::c_char,
        chan: usize,
        gain_range_out: uhd_meta_range_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get a list of RX gain names for the given channel"]
    pub fn uhd_usrp_get_rx_gain_names(
        h: uhd_usrp_handle,
        chan: usize,
        gain_names_out: *mut uhd_string_vector_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set the RX antenna for the given channel"]
    pub fn uhd_usrp_set_rx_antenna(
        h: uhd_usrp_handle,
        ant: *const ::std::os::raw::c_char,
        chan: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the RX antenna for the given channel"]
    pub fn uhd_usrp_get_rx_antenna(
        h: uhd_usrp_handle,
        chan: usize,
        ant_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get a list of RX antennas associated with the given channels"]
    pub fn uhd_usrp_get_rx_antennas(
        h: uhd_usrp_handle,
        chan: usize,
        antennas_out: *mut uhd_string_vector_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get a list of RX sensors associated with the given channels"]
    pub fn uhd_usrp_get_rx_sensor_names(
        h: uhd_usrp_handle,
        chan: usize,
        sensor_names_out: *mut uhd_string_vector_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set the bandwidth for the given channel's RX frontend"]
    pub fn uhd_usrp_set_rx_bandwidth(h: uhd_usrp_handle, bandwidth: f64, chan: usize) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the bandwidth for the given channel's RX frontend"]
    pub fn uhd_usrp_get_rx_bandwidth(
        h: uhd_usrp_handle,
        chan: usize,
        bandwidth_out: *mut f64,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get all possible bandwidth ranges for the given channel's RX frontend"]
    pub fn uhd_usrp_get_rx_bandwidth_range(
        h: uhd_usrp_handle,
        chan: usize,
        bandwidth_range_out: uhd_meta_range_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the value for the given RX sensor"]
    pub fn uhd_usrp_get_rx_sensor(
        h: uhd_usrp_handle,
        name: *const ::std::os::raw::c_char,
        chan: usize,
        sensor_value_out: *mut uhd_sensor_value_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Enable or disable RX DC offset correction for the given channel\n*!\n* See uhd::usrp::multi_usrp::set_rx_dc_offset() for more details.\n*/"]
    pub fn uhd_usrp_set_rx_dc_offset_enabled(
        h: uhd_usrp_handle,
        enb: bool,
        chan: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Enable or disable RX IQ imbalance correction for the given channel"]
    pub fn uhd_usrp_set_rx_iq_balance_enabled(
        h: uhd_usrp_handle,
        enb: bool,
        chan: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Map the given device's TX frontend to a channel\n*!\n* See uhd::usrp::multi_usrp::set_tx_subdev_spec() for more details.\n*/"]
    pub fn uhd_usrp_set_tx_subdev_spec(
        h: uhd_usrp_handle,
        subdev_spec: uhd_subdev_spec_handle,
        mboard: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the TX frontend specification for the given device"]
    pub fn uhd_usrp_get_tx_subdev_spec(
        h: uhd_usrp_handle,
        mboard: usize,
        subdev_spec_out: uhd_subdev_spec_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the number of TX channels for the given handle"]
    pub fn uhd_usrp_get_tx_num_channels(
        h: uhd_usrp_handle,
        num_channels_out: *mut usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the name for the RX frontend"]
    pub fn uhd_usrp_get_tx_subdev_name(
        h: uhd_usrp_handle,
        chan: usize,
        tx_subdev_name_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set the given RX channel's sample rate (in Sps)"]
    pub fn uhd_usrp_set_tx_rate(h: uhd_usrp_handle, rate: f64, chan: usize) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the given RX channel's sample rate (in Sps)"]
    pub fn uhd_usrp_get_tx_rate(h: uhd_usrp_handle, chan: usize, rate_out: *mut f64) -> uhd_error;
}
extern "C" {
    #[doc = "! Get a range of possible RX rates for the given channel"]
    pub fn uhd_usrp_get_tx_rates(
        h: uhd_usrp_handle,
        chan: usize,
        rates_out: uhd_meta_range_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set the given channel's center TX frequency"]
    pub fn uhd_usrp_set_tx_freq(
        h: uhd_usrp_handle,
        tune_request: *mut uhd_tune_request_t,
        chan: usize,
        tune_result: *mut uhd_tune_result_t,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the given channel's center TX frequency"]
    pub fn uhd_usrp_get_tx_freq(h: uhd_usrp_handle, chan: usize, freq_out: *mut f64) -> uhd_error;
}
extern "C" {
    #[doc = "! Get all possible center frequency ranges for the given channel\n*!\n* See uhd::usrp::multi_usrp::get_rx_freq_range() for more details.\n*/"]
    pub fn uhd_usrp_get_tx_freq_range(
        h: uhd_usrp_handle,
        chan: usize,
        freq_range_out: uhd_meta_range_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get all possible RF frequency ranges for the given channel's TX RF frontend"]
    pub fn uhd_usrp_get_fe_tx_freq_range(
        h: uhd_usrp_handle,
        chan: usize,
        freq_range_out: uhd_meta_range_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get a list of possible LO stage names"]
    pub fn uhd_usrp_get_tx_lo_names(
        h: uhd_usrp_handle,
        chan: usize,
        tx_lo_names_out: *mut uhd_string_vector_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set the LO source for the USRP device"]
    pub fn uhd_usrp_set_tx_lo_source(
        h: uhd_usrp_handle,
        src: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        chan: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the currently set LO source"]
    pub fn uhd_usrp_get_tx_lo_source(
        h: uhd_usrp_handle,
        name: *const ::std::os::raw::c_char,
        chan: usize,
        tx_lo_source_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get a list of possible LO sources"]
    pub fn uhd_usrp_get_tx_lo_sources(
        h: uhd_usrp_handle,
        name: *const ::std::os::raw::c_char,
        chan: usize,
        tx_lo_sources_out: *mut uhd_string_vector_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set whether the LO used by the USRP device is exported"]
    pub fn uhd_usrp_set_tx_lo_export_enabled(
        h: uhd_usrp_handle,
        enabled: bool,
        name: *const ::std::os::raw::c_char,
        chan: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Returns true if the currently selected LO is being exported."]
    pub fn uhd_usrp_get_tx_lo_export_enabled(
        h: uhd_usrp_handle,
        name: *const ::std::os::raw::c_char,
        chan: usize,
        result_out: *mut bool,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set the Tx LO frequency."]
    pub fn uhd_usrp_set_tx_lo_freq(
        h: uhd_usrp_handle,
        freq: f64,
        name: *const ::std::os::raw::c_char,
        chan: usize,
        coerced_freq_out: *mut f64,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the current Tx LO frequency."]
    pub fn uhd_usrp_get_tx_lo_freq(
        h: uhd_usrp_handle,
        name: *const ::std::os::raw::c_char,
        chan: usize,
        tx_lo_freq_out: *mut f64,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set the TX gain for the given channel and name"]
    pub fn uhd_usrp_set_tx_gain(
        h: uhd_usrp_handle,
        gain: f64,
        chan: usize,
        gain_name: *const ::std::os::raw::c_char,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set the normalized TX gain [0.0, 1.0] for the given channel\n*!\n* See uhd::usrp::multi_usrp::set_normalized_tx_gain() for more details.\n*/"]
    pub fn uhd_usrp_set_normalized_tx_gain(h: uhd_usrp_handle, gain: f64, chan: usize)
        -> uhd_error;
}
extern "C" {
    #[doc = "! Get all possible gain ranges for the given channel and name"]
    pub fn uhd_usrp_get_tx_gain_range(
        h: uhd_usrp_handle,
        name: *const ::std::os::raw::c_char,
        chan: usize,
        gain_range_out: uhd_meta_range_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the given channel's RX gain"]
    pub fn uhd_usrp_get_tx_gain(
        h: uhd_usrp_handle,
        chan: usize,
        gain_name: *const ::std::os::raw::c_char,
        gain_out: *mut f64,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the given channel's normalized TX gain [0.0, 1.0]\n*!\n* See uhd::usrp::multi_usrp::get_normalized_tx_gain() for more details.\n*/"]
    pub fn uhd_usrp_get_normalized_tx_gain(
        h: uhd_usrp_handle,
        chan: usize,
        gain_out: *mut f64,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get a list of TX gain names for the given channel"]
    pub fn uhd_usrp_get_tx_gain_names(
        h: uhd_usrp_handle,
        chan: usize,
        gain_names_out: *mut uhd_string_vector_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set the TX antenna for the given channel"]
    pub fn uhd_usrp_set_tx_antenna(
        h: uhd_usrp_handle,
        ant: *const ::std::os::raw::c_char,
        chan: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the TX antenna for the given channel"]
    pub fn uhd_usrp_get_tx_antenna(
        h: uhd_usrp_handle,
        chan: usize,
        ant_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get a list of tx antennas associated with the given channels"]
    pub fn uhd_usrp_get_tx_antennas(
        h: uhd_usrp_handle,
        chan: usize,
        antennas_out: *mut uhd_string_vector_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set the bandwidth for the given channel's TX frontend"]
    pub fn uhd_usrp_set_tx_bandwidth(h: uhd_usrp_handle, bandwidth: f64, chan: usize) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the bandwidth for the given channel's TX frontend"]
    pub fn uhd_usrp_get_tx_bandwidth(
        h: uhd_usrp_handle,
        chan: usize,
        bandwidth_out: *mut f64,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get all possible bandwidth ranges for the given channel's TX frontend"]
    pub fn uhd_usrp_get_tx_bandwidth_range(
        h: uhd_usrp_handle,
        chan: usize,
        bandwidth_range_out: uhd_meta_range_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get the value for the given TX sensor"]
    pub fn uhd_usrp_get_tx_sensor(
        h: uhd_usrp_handle,
        name: *const ::std::os::raw::c_char,
        chan: usize,
        sensor_value_out: *mut uhd_sensor_value_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get a list of TX sensors associated with the given channels"]
    pub fn uhd_usrp_get_tx_sensor_names(
        h: uhd_usrp_handle,
        chan: usize,
        sensor_names_out: *mut uhd_string_vector_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get a list of GPIO banks associated with the given channels"]
    pub fn uhd_usrp_get_gpio_banks(
        h: uhd_usrp_handle,
        mboard: usize,
        gpio_banks_out: *mut uhd_string_vector_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Set a GPIO attribute for a given GPIO bank\n*!\n* See uhd::usrp::multi_usrp::set_gpio_attr() for more details.\n*/"]
    pub fn uhd_usrp_set_gpio_attr(
        h: uhd_usrp_handle,
        bank: *const ::std::os::raw::c_char,
        attr: *const ::std::os::raw::c_char,
        value: u32,
        mask: u32,
        mboard: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get a GPIO attribute on a particular GPIO bank\n*!\n* See uhd::usrp::multi_usrp::get_gpio_attr() for more details.\n*/"]
    pub fn uhd_usrp_get_gpio_attr(
        h: uhd_usrp_handle,
        bank: *const ::std::os::raw::c_char,
        attr: *const ::std::os::raw::c_char,
        mboard: usize,
        attr_out: *mut u32,
    ) -> uhd_error;
}
#[doc = " Public Datatypes for USRP clock"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct uhd_usrp_clock {
    _unused: [u8; 0],
}
#[doc = "! A C-level interface for interacting with an Ettus Research clock device\n*!\n* See uhd::usrp_clock::multi_usrp_clock for more details.\n*\n* NOTE: Attempting to use a handle before passing it into uhd_usrp_clock_make()\n* will result in undefined behavior.\n*/"]
pub type uhd_usrp_clock_handle = *mut uhd_usrp_clock;
extern "C" {
    #[doc = "! Find all connected clock devices.\n*!\n* See uhd::device::find() for more details.\n*/"]
    pub fn uhd_usrp_clock_find(
        args: *const ::std::os::raw::c_char,
        devices_out: *mut uhd_string_vector_t,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Create a clock handle.\n*!\n* \\param h The handle\n* \\param args Device args (e.g. \"addr=192.168.10.3\")\n*/"]
    pub fn uhd_usrp_clock_make(
        h: *mut uhd_usrp_clock_handle,
        args: *const ::std::os::raw::c_char,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Safely destroy the clock object underlying the handle.\n*!\n* Note: After calling this, usage of h may cause segmentation faults.\n* However, multiple calling of uhd_usrp_free() is safe.\n*/"]
    pub fn uhd_usrp_clock_free(h: *mut uhd_usrp_clock_handle) -> uhd_error;
}
extern "C" {
    #[doc = "! Get last error"]
    pub fn uhd_usrp_clock_last_error(
        h: uhd_usrp_clock_handle,
        error_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get board information in a nice output"]
    pub fn uhd_usrp_clock_get_pp_string(
        h: uhd_usrp_clock_handle,
        pp_string_out: *mut ::std::os::raw::c_char,
        strbuffer_len: usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get number of boards"]
    pub fn uhd_usrp_clock_get_num_boards(
        h: uhd_usrp_clock_handle,
        num_boards_out: *mut usize,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get time"]
    pub fn uhd_usrp_clock_get_time(
        h: uhd_usrp_clock_handle,
        board: usize,
        clock_time_out: *mut u32,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get sensor"]
    pub fn uhd_usrp_clock_get_sensor(
        h: uhd_usrp_clock_handle,
        name: *const ::std::os::raw::c_char,
        board: usize,
        sensor_value_out: *mut uhd_sensor_value_handle,
    ) -> uhd_error;
}
extern "C" {
    #[doc = "! Get sensor names"]
    pub fn uhd_usrp_clock_get_sensor_names(
        h: uhd_usrp_clock_handle,
        board: usize,
        sensor_names_out: *mut uhd_string_vector_handle,
    ) -> uhd_error;
}
pub const uhd_log_severity_level_t_UHD_LOG_LEVEL_TRACE: uhd_log_severity_level_t = 0;
pub const uhd_log_severity_level_t_UHD_LOG_LEVEL_DEBUG: uhd_log_severity_level_t = 1;
pub const uhd_log_severity_level_t_UHD_LOG_LEVEL_INFO: uhd_log_severity_level_t = 2;
pub const uhd_log_severity_level_t_UHD_LOG_LEVEL_WARNING: uhd_log_severity_level_t = 3;
pub const uhd_log_severity_level_t_UHD_LOG_LEVEL_ERROR: uhd_log_severity_level_t = 4;
pub const uhd_log_severity_level_t_UHD_LOG_LEVEL_FATAL: uhd_log_severity_level_t = 5;
pub type uhd_log_severity_level_t = ::std::os::raw::c_int;
extern "C" {
    pub fn _uhd_log(
        log_level: uhd_log_severity_level_t,
        filename: *const ::std::os::raw::c_char,
        lineno: ::std::os::raw::c_int,
        comp: *const ::std::os::raw::c_char,
        format: *const ::std::os::raw::c_char,
        ...
    );
}
pub const uhd_default_thread_priority: f32 = 0.5;
extern "C" {
    #[doc = " Set the scheduling priority on the current thread.\n\n A new thread or calling process should make this call\n with the defaults this to enable realtime scheduling.\n\n A priority of zero corresponds to normal priority.\n Positive priority values are higher than normal.\n Negative priority values are lower than normal.\n\n \\param priority a value between -1 and 1\n \\param realtime true to use realtime mode\n \\return UHD error code"]
    pub fn uhd_set_thread_priority(priority: f32, realtime: bool) -> uhd_error;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
